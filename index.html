<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gemini RPG Engine V9 - å‘½é‹ç¹”ç¶²</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@200;400;700;900&display=swap');

        *, *::before, *::after { box-sizing: border-box; }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #15171e;
            font-family: 'Noto Serif TC', serif;
            -webkit-tap-highlight-color: transparent;
        }

        #gameCanvas {
            display: block;
            touch-action: none;
        }

        /* å­—é«”é è¼‰ */
        .font-preload {
            position: absolute;
            opacity: 0;
            pointer-events: none;
            font-family: 'Noto Serif TC', serif;
        }

        /* å·¥å…·åˆ— */
        .toolbar {
            position: absolute;
            top: 12px;
            right: 12px;
            display: flex;
            gap: 8px;
            z-index: 10;
        }

        @media (min-width: 600px) {
            .toolbar { top: 20px; right: 20px; gap: 12px; }
        }

        .tool-btn {
            background: rgba(20, 22, 30, 0.9);
            border: 1px solid #3a3d4a;
            color: #7a7d8a;
            width: 42px;
            height: 42px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.3s ease;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            position: relative;
        }

        .tool-btn:hover, .tool-btn:active {
            border-color: #c9a227;
            color: #c9a227;
            box-shadow: 0 0 15px rgba(201, 162, 39, 0.2);
        }

        .tool-btn.active {
            color: #c9a227;
            border-color: #c9a227;
            background: rgba(201, 162, 39, 0.1);
        }

        /* å¾½ç«  */
        .tool-btn .badge {
            position: absolute;
            top: -4px;
            right: -4px;
            background: linear-gradient(135deg, #c9a227, #a8860f);
            color: #0d0f14;
            font-size: 11px;
            font-weight: 700;
            min-width: 18px;
            height: 18px;
            border-radius: 9px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 4px;
        }

        /* æ—¥æ›†é¡¯ç¤º */
        .calendar-display {
            position: absolute;
            top: 12px;
            left: 12px;
            background: rgba(20, 22, 30, 0.9);
            border: 1px solid #3a3d4a;
            border-radius: 8px;
            padding: 10px 16px;
            color: #b0a080;
            font-size: 14px;
            backdrop-filter: blur(8px);
            z-index: 10;
        }

        .calendar-display .date {
            font-weight: 700;
            font-size: 16px;
            color: #d4c4a0;
        }

        .calendar-display .time {
            font-size: 12px;
            color: #7a7d8a;
            margin-top: 2px;
        }

        /* å‘½é‹é»é¡¯ç¤º */
        .fate-points {
            position: absolute;
            top: 60px;
            left: 12px;
            background: linear-gradient(135deg, rgba(30, 25, 40, 0.95), rgba(20, 18, 30, 0.95));
            border: 1px solid #5a4a7a;
            border-radius: 8px;
            padding: 8px 14px;
            color: #a090c0;
            font-size: 14px;
            backdrop-filter: blur(8px);
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .fate-points .icon {
            font-size: 18px;
        }

        .fate-points .value {
            font-weight: 900;
            font-size: 18px;
            color: #c0a0e0;
        }

        /* æ¨¡æ…‹è¦–çª— */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: linear-gradient(180deg, #1a1c24 0%, #14161c 100%);
            border: 1px solid #3a3d4a;
            width: 95%;
            max-width: 900px;
            max-height: 90vh;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8);
            overflow-y: auto;
            position: relative;
            transform: translateY(20px) scale(0.98);
            transition: transform 0.3s ease;
        }

        @media (min-width: 600px) {
            .modal-content { padding: 30px; }
        }

        .modal-overlay.show .modal-content {
            transform: translateY(0) scale(1);
        }

        .modal-title {
            font-weight: 900;
            font-size: 24px;
            color: #c9a227;
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #2a2d3a;
            letter-spacing: 3px;
        }

        .close-btn {
            position: absolute;
            top: 15px;
            right: 18px;
            color: #6a6d7a;
            cursor: pointer;
            font-size: 28px;
            font-weight: 200;
            line-height: 1;
            padding: 5px;
            transition: color 0.2s;
        }
        .close-btn:hover { color: #fff; }

        /* é—œä¿‚ç¶²ç•«å¸ƒ */
        #relationCanvas {
            width: 100%;
            height: 400px;
            background: radial-gradient(ellipse at center, #1a1c24 0%, #0d0f14 100%);
            border-radius: 8px;
            border: 1px solid #2a2d3a;
        }

        @media (min-width: 600px) {
            #relationCanvas { height: 500px; }
        }

        /* NPC è©³æƒ…é¢æ¿ */
        .npc-detail-panel {
            background: rgba(25, 27, 35, 0.95);
            border: 1px solid #3a3d4a;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            display: none;
        }

        .npc-detail-panel.show { display: block; }

        .npc-detail-panel h3 {
            color: #d4c4a0;
            margin: 0 0 10px 0;
            font-size: 20px;
        }

        .npc-detail-panel .role {
            color: #7a7d8a;
            font-size: 14px;
            margin-bottom: 15px;
        }

        .npc-detail-panel .desc {
            color: #a0a5b0;
            line-height: 1.8;
            font-size: 15px;
        }

        .npc-detail-panel .relations {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #2a2d3a;
        }

        .npc-detail-panel .relation-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .relation-item .target { color: #b0a080; }
        .relation-item .status { font-size: 13px; padding: 3px 10px; border-radius: 12px; }
        .relation-item .status.love { background: rgba(200, 100, 120, 0.3); color: #e0a0b0; }
        .relation-item .status.ally { background: rgba(100, 180, 120, 0.3); color: #a0d0b0; }
        .relation-item .status.neutral { background: rgba(150, 150, 150, 0.3); color: #b0b0b0; }
        .relation-item .status.rival { background: rgba(200, 150, 80, 0.3); color: #d0c090; }
        .relation-item .status.enemy { background: rgba(180, 80, 80, 0.3); color: #d0a0a0; }

        /* å‘½é‹å¹²æ¶‰æŒ‰éˆ• */
        .fate-action-btn {
            background: linear-gradient(135deg, #3a2a5a, #2a1a4a);
            border: 1px solid #5a4a7a;
            color: #c0a0e0;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
            margin-top: 15px;
            transition: all 0.3s;
        }

        .fate-action-btn:hover {
            background: linear-gradient(135deg, #4a3a6a, #3a2a5a);
            box-shadow: 0 0 20px rgba(160, 120, 200, 0.3);
        }

        .fate-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .fate-action-btn .cost {
            font-size: 12px;
            opacity: 0.7;
        }

        /* ä¸–ç•Œè§€å±•ç¤º */
        .world-intro {
            text-align: center;
            padding: 40px 20px;
        }

        .world-intro h2 {
            font-size: 32px;
            font-weight: 900;
            color: #c9a227;
            margin-bottom: 20px;
            letter-spacing: 4px;
        }

        .world-intro .desc {
            font-size: 18px;
            color: #a0a5b0;
            line-height: 2;
            max-width: 600px;
            margin: 0 auto 30px;
        }

        .world-intro .factions {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
        }

        .faction-card {
            background: rgba(30, 32, 40, 0.9);
            border: 1px solid #3a3d4a;
            border-radius: 8px;
            padding: 20px;
            width: 250px;
            text-align: left;
        }

        .faction-card h4 {
            color: #d4c4a0;
            margin: 0 0 10px 0;
            font-size: 18px;
        }

        .faction-card p {
            color: #8a8d9a;
            font-size: 14px;
            line-height: 1.6;
            margin: 0;
        }

        .start-adventure-btn {
            background: linear-gradient(135deg, #c9a227, #a8860f);
            border: none;
            color: #0d0f14;
            padding: 15px 50px;
            border-radius: 8px;
            font-family: inherit;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            margin-top: 30px;
            transition: all 0.3s;
            letter-spacing: 2px;
        }

        .start-adventure-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(201, 162, 39, 0.4);
        }

        /* API Key è¨­å®š */
        .api-key-section {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(201, 162, 39, 0.05);
            border: 1px solid #3a3d4a;
            border-radius: 8px;
        }

        .api-key-section label {
            display: block;
            font-size: 14px;
            color: #7a7d8a;
            margin-bottom: 8px;
        }

        .api-key-section input {
            width: 100%;
            padding: 12px;
            background: #0d0f14;
            border: 1px solid #3a3d4a;
            border-radius: 6px;
            color: #d0d0d0;
            font-family: inherit;
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
        }

        .api-key-section input:focus { border-color: #c9a227; }

        /* éŒ¯èª¤æç¤º */
        .error-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: rgba(180, 60, 60, 0.95);
            color: #fff;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 200;
            opacity: 0;
            transition: all 0.3s ease;
            max-width: 90%;
            text-align: center;
        }

        .error-toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* æ²è»¸æ¨£å¼ */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #0d0f14; }
        ::-webkit-scrollbar-thumb { background: #3a3d4a; border-radius: 3px; }

        /* è§’è‰²å‰µå»ºè¡¨å–® */
        .character-create-form {
            padding: 10px;
        }

        .character-create-form .form-group {
            margin-bottom: 20px;
        }

        .character-create-form label {
            display: block;
            font-size: 14px;
            color: #deb887;
            margin-bottom: 8px;
            font-weight: 700;
        }

        .character-create-form input[type="text"] {
            width: 100%;
            padding: 12px;
            background: #15171e;
            border: 1px solid #4a4d5e;
            border-radius: 6px;
            color: #d8d8d0;
            font-family: inherit;
            font-size: 16px;
            outline: none;
        }

        .character-create-form input[type="text"]:focus {
            border-color: #deb887;
        }

        .character-create-form select {
            width: 100%;
            padding: 12px;
            background: #15171e;
            border: 1px solid #4a4d5e;
            border-radius: 6px;
            color: #d8d8d0;
            font-family: inherit;
            font-size: 14px;
            outline: none;
            cursor: pointer;
        }

        .character-create-form select:focus {
            border-color: #deb887;
        }

        .radio-group, .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .radio-item, .checkbox-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            background: #1a1c24;
            border: 1px solid #3a3d4a;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .radio-item:hover, .checkbox-item:hover {
            border-color: #deb887;
        }

        .radio-item input, .checkbox-item input {
            display: none;
        }

        .radio-item input:checked + span,
        .checkbox-item input:checked + span {
            color: #deb887;
        }

        .radio-item:has(input:checked),
        .checkbox-item:has(input:checked) {
            border-color: #deb887;
            background: rgba(222, 184, 135, 0.1);
        }

        .radio-item span, .checkbox-item span {
            color: #a0a5b0;
            font-size: 14px;
        }

        .checkbox-item small {
            color: #6a6d7a;
            font-size: 11px;
            margin-left: 4px;
        }

        .stat-allocator {
            background: #15171e;
            border: 1px solid #3a3d4a;
            border-radius: 8px;
            padding: 15px;
        }

        .stat-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-name {
            color: #d8d8d0;
            font-weight: 700;
            font-size: 14px;
            min-width: 80px;
        }

        .stat-desc {
            color: #6a6d7a;
            font-size: 12px;
            flex: 1;
            margin: 0 10px;
        }

        .stat-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 1px solid #4a4d5e;
            background: #1a1c24;
            color: #d8d8d0;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .stat-btn:hover {
            border-color: #deb887;
            color: #deb887;
        }

        .stat-value {
            color: #deb887;
            font-weight: 900;
            font-size: 18px;
            min-width: 24px;
            text-align: center;
        }

        @media (max-width: 600px) {
            .stat-row {
                flex-wrap: wrap;
            }
            .stat-desc {
                width: 100%;
                margin: 5px 0;
                order: 3;
            }
            .stat-controls {
                margin-left: auto;
            }
        }

        /* å‘½é‹é•·æ²³æ™‚é–“ç·š */
        .timeline-container {
            max-height: 500px;
            overflow-y: auto;
            padding: 20px 10px;
        }

        .timeline-empty {
            text-align: center;
            color: #6a6d7a;
            padding: 40px;
        }

        .timeline-item {
            position: relative;
            padding: 15px 20px;
            margin-left: 30px;
            border-left: 2px solid #3a3d4a;
            cursor: pointer;
            transition: all 0.2s;
        }

        .timeline-item:hover {
            background: rgba(222, 184, 135, 0.05);
        }

        .timeline-item::before {
            content: '';
            position: absolute;
            left: -8px;
            top: 20px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #3a3d4a;
            border: 2px solid #15171e;
        }

        .timeline-item.major::before {
            background: linear-gradient(135deg, #deb887, #c9a227);
            box-shadow: 0 0 10px rgba(222, 184, 135, 0.5);
        }

        .timeline-item.selected {
            background: rgba(222, 184, 135, 0.1);
            border-left-color: #deb887;
        }

        .timeline-date {
            font-size: 12px;
            color: #8f919c;
            margin-bottom: 5px;
        }

        .timeline-name {
            font-size: 15px;
            color: #d8d8d0;
            font-weight: 700;
        }

        .timeline-item.major .timeline-name {
            color: #deb887;
        }

        .timeline-detail {
            margin-top: 15px;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            display: none;
        }

        .timeline-detail.show {
            display: block;
        }

        .timeline-detail-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            font-size: 13px;
            color: #a0a5b0;
        }

        .timeline-detail-row span:first-child {
            color: #6a6d7a;
        }

        .timeline-revert-btn {
            width: 100%;
            margin-top: 15px;
            padding: 12px;
            background: linear-gradient(135deg, #4a3a6a, #3a2a5a);
            border: 1px solid #5a4a7a;
            border-radius: 6px;
            color: #c0a0e0;
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .timeline-revert-btn:hover {
            background: linear-gradient(135deg, #5a4a7a, #4a3a6a);
            box-shadow: 0 0 15px rgba(160, 120, 200, 0.3);
        }

        .timeline-revert-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .timeline-cost {
            font-size: 12px;
            color: #8f919c;
        }

        /* æ“²éª°æª¢å®š Overlay */
        .dice-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .dice-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .dice-container {
            text-align: center;
            max-width: 400px;
            padding: 30px;
        }

        .dice-title {
            font-size: 20px;
            color: #deb887;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .dice-attribute {
            font-size: 14px;
            color: #8f919c;
            margin-bottom: 20px;
        }

        .dice-display {
            font-size: 72px;
            font-weight: 900;
            color: #d8d8d0;
            margin: 20px 0;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
            transition: all 0.3s;
        }

        .dice-display.rolling {
            animation: diceRoll 0.1s infinite;
        }

        .dice-display.success {
            color: #80c090;
            text-shadow: 0 0 30px rgba(100, 200, 140, 0.5);
        }

        .dice-display.failure {
            color: #c07070;
            text-shadow: 0 0 30px rgba(200, 100, 100, 0.5);
        }

        @keyframes diceRoll {
            0% { transform: rotate(-5deg) scale(1.05); }
            50% { transform: rotate(5deg) scale(0.95); }
            100% { transform: rotate(-5deg) scale(1.05); }
        }

        .dice-threshold {
            font-size: 14px;
            color: #8f919c;
            margin-bottom: 20px;
        }

        .dice-result-text {
            font-size: 24px;
            font-weight: 700;
            margin: 20px 0;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .dice-result-text.show {
            opacity: 1;
        }

        .dice-result-text.success {
            color: #80c090;
        }

        .dice-result-text.failure {
            color: #c07070;
        }

        .dice-reroll-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .dice-reroll-section.show {
            opacity: 1;
        }

        .dice-reroll-btn {
            padding: 12px 30px;
            background: linear-gradient(135deg, #4a3a6a, #3a2a5a);
            border: 1px solid #5a4a7a;
            border-radius: 8px;
            color: #c0a0e0;
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            margin: 0 10px;
        }

        .dice-reroll-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #5a4a7a, #4a3a6a);
            box-shadow: 0 0 15px rgba(160, 120, 200, 0.3);
        }

        .dice-reroll-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .dice-continue-btn {
            padding: 12px 30px;
            background: linear-gradient(135deg, #3a4a3a, #2a3a2a);
            border: 1px solid #4a5a4a;
            border-radius: 8px;
            color: #a0c0a0;
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            margin: 0 10px;
        }

        .dice-continue-btn:hover {
            background: linear-gradient(135deg, #4a5a4a, #3a4a3a);
        }

        .dice-stat-bonus {
            font-size: 12px;
            color: #6a6d7a;
            margin-top: 10px;
        }
    </style>
</head>
<body>

    <div class="font-preload" aria-hidden="true">
        <span style="font-weight:200">è¼‰</span>
        <span style="font-weight:400">è¼‰</span>
        <span style="font-weight:700">è¼‰</span>
        <span style="font-weight:900">è¼‰</span>
    </div>

    <!-- æ—¥æ›† -->
    <div id="calendar-display" class="calendar-display" style="display:none;">
        <div class="date" id="calendar-date">ç¬¬ä¸€å¹´ æ˜¥æœˆ åˆä¸€</div>
        <div class="time" id="calendar-time">æ¸…æ™¨</div>
    </div>

    <!-- å‘½é‹é» -->
    <div id="fate-display" class="fate-points" style="display:none;">
        <span class="icon">âœ§</span>
        <span class="value" id="fate-value">0</span>
    </div>

    <!-- å·¥å…·åˆ— -->
    <div class="toolbar">
        <button id="btn-relation" class="tool-btn" title="äººç‰©é—œä¿‚ç¶²">
            ğŸ•¸ï¸
            <span class="badge" id="npc-count" style="display:none;">0</span>
        </button>
        <button id="btn-timeline" class="tool-btn" title="å‘½é‹é•·æ²³">â³</button>
        <button id="btn-sound" class="tool-btn" title="èªéŸ³æ—ç™½">ğŸ”‡</button>
        <button id="btn-log" class="tool-btn" title="å†’éšªç·¨å¹´å²">ğŸ“œ</button>
        <button id="btn-settings" class="tool-btn" title="è¨­å®š">âš™ï¸</button>
    </div>

    <!-- éŒ¯èª¤æç¤º -->
    <div id="error-toast" class="error-toast" role="alert"></div>

    <!-- æ“²éª°æª¢å®š Overlay -->
    <div id="dice-overlay" class="dice-overlay">
        <div class="dice-container">
            <div class="dice-title" id="dice-title">å‘½é‹æª¢å®š</div>
            <div class="dice-attribute" id="dice-attribute">åŠ›é‡æª¢å®š</div>
            <div class="dice-display" id="dice-display">?</div>
            <div class="dice-threshold" id="dice-threshold">ç›®æ¨™ï¼š8 ä»¥ä¸Š</div>
            <div class="dice-result-text" id="dice-result-text">æˆåŠŸï¼</div>
            <div class="dice-stat-bonus" id="dice-stat-bonus"></div>
            <div class="dice-reroll-section" id="dice-reroll-section">
                <button class="dice-reroll-btn" id="dice-reroll-btn" onclick="rerollDice()">
                    âœ§ å‘½é‹ä»‹å…¥ (3é»)
                </button>
                <button class="dice-continue-btn" id="dice-continue-btn" onclick="continueDiceResult()">
                    æ¥å—å‘½é‹
                </button>
            </div>
        </div>
    </div>

    <!-- é—œä¿‚ç¶²è¦–çª— -->
    <div id="relation-modal" class="modal-overlay">
        <div class="modal-content">
            <span class="close-btn" onclick="toggleRelationModal(false)">Ã—</span>
            <div class="modal-title">å‘½ é‹ ç¹” ç¶²</div>
            <canvas id="relationCanvas"></canvas>
            <div id="npc-detail" class="npc-detail-panel"></div>
        </div>
    </div>

    <!-- ç·¨å¹´å²è¦–çª— -->
    <div id="log-modal" class="modal-overlay">
        <div class="modal-content">
            <span class="close-btn" onclick="toggleLogModal(false)">Ã—</span>
            <div class="modal-title">å†’ éšª ç·¨ å¹´ å²</div>
            <div id="log-body" style="color:#a0a5b0;line-height:2;white-space:pre-wrap;"></div>
        </div>
    </div>

    <!-- è¨­å®šè¦–çª— -->
    <div id="settings-modal" class="modal-overlay">
        <div class="modal-content" style="max-width:500px;">
            <span class="close-btn" onclick="toggleSettingsModal(false)">Ã—</span>
            <div class="modal-title">å¼• æ“ è¨­ å®š</div>
            <div class="api-key-section">
                <label>Gemini API Key</label>
                <input type="password" id="api-key-input" placeholder="è¼¸å…¥ä½ çš„ API Key...">
            </div>
            <div style="text-align:center;">
                <button class="start-adventure-btn" style="padding:12px 40px;font-size:16px;" onclick="saveApiKey()">å„²å­˜</button>
            </div>
            <div style="text-align:center;margin-top:20px;padding-top:20px;border-top:1px solid #3a3d4a;">
                <button class="fate-action-btn" style="background:linear-gradient(135deg,#5a3030,#4a2020);" onclick="clearAutoSave();toggleSettingsModal(false);">
                    ğŸ—‘ï¸ æ¸…é™¤å­˜æª”
                </button>
            </div>
        </div>
    </div>

    <!-- ä¸–ç•Œè§€å±•ç¤ºè¦–çª— -->
    <div id="world-intro-modal" class="modal-overlay">
        <div class="modal-content" style="max-width:800px;">
            <div id="world-intro-content" class="world-intro"></div>
        </div>
    </div>

    <!-- å‘½é‹é•·æ²³è¦–çª— -->
    <div id="timeline-modal" class="modal-overlay">
        <div class="modal-content" style="max-width:600px;">
            <span class="close-btn" onclick="toggleTimelineModal(false)">Ã—</span>
            <div class="modal-title">å‘½ é‹ é•· æ²³</div>
            <div id="timeline-content" class="timeline-container"></div>
        </div>
    </div>

    <!-- è§’è‰²å‰µå»ºè¦–çª— -->
    <div id="character-create-modal" class="modal-overlay">
        <div class="modal-content" style="max-width:600px;">
            <div class="modal-title">è§’ è‰² å‰µ å»º</div>
            <div class="character-create-form">
                <!-- å§“å -->
                <div class="form-group">
                    <label>è§’è‰²å§“å</label>
                    <input type="text" id="char-name" placeholder="ç„¡åæ—…äºº" maxlength="10">
                </div>

                <!-- æ€§åˆ¥ -->
                <div class="form-group">
                    <label>æ€§åˆ¥</label>
                    <div class="radio-group" id="char-gender">
                        <label class="radio-item"><input type="radio" name="gender" value="ç”·" checked><span>ç”·</span></label>
                        <label class="radio-item"><input type="radio" name="gender" value="å¥³"><span>å¥³</span></label>
                        <label class="radio-item"><input type="radio" name="gender" value="å…¶ä»–"><span>å…¶ä»–</span></label>
                        <label class="radio-item"><input type="radio" name="gender" value="ä¸æŒ‡å®š"><span>ä¸æŒ‡å®š</span></label>
                    </div>
                </div>

                <!-- åˆå§‹å±¬æ€§ -->
                <div class="form-group">
                    <label>åˆå§‹å±¬æ€§ <span id="stat-points-remaining" style="color:#deb887;">(å‰©é¤˜é»æ•¸: 10)</span></label>
                    <div class="stat-allocator">
                        <div class="stat-row">
                            <span class="stat-name">ğŸ’ª åŠ›é‡</span>
                            <span class="stat-desc">å½±éŸ¿æˆ°é¬¥ã€é«”åŠ›ç›¸é—œåˆ¤å®š</span>
                            <div class="stat-controls">
                                <button class="stat-btn" onclick="adjustStat('strength', -1)">-</button>
                                <span id="stat-strength" class="stat-value">0</span>
                                <button class="stat-btn" onclick="adjustStat('strength', 1)">+</button>
                            </div>
                        </div>
                        <div class="stat-row">
                            <span class="stat-name">ğŸ“š æ™ºæ…§</span>
                            <span class="stat-desc">å½±éŸ¿è§£è¬ã€çŸ¥è­˜ç›¸é—œåˆ¤å®š</span>
                            <div class="stat-controls">
                                <button class="stat-btn" onclick="adjustStat('wisdom', -1)">-</button>
                                <span id="stat-wisdom" class="stat-value">0</span>
                                <button class="stat-btn" onclick="adjustStat('wisdom', 1)">+</button>
                            </div>
                        </div>
                        <div class="stat-row">
                            <span class="stat-name">ğŸ’¬ é­…åŠ›</span>
                            <span class="stat-desc">å½±éŸ¿ç¤¾äº¤ã€èªªæœç›¸é—œåˆ¤å®š</span>
                            <div class="stat-controls">
                                <button class="stat-btn" onclick="adjustStat('charisma', -1)">-</button>
                                <span id="stat-charisma" class="stat-value">0</span>
                                <button class="stat-btn" onclick="adjustStat('charisma', 1)">+</button>
                            </div>
                        </div>
                        <div class="stat-row">
                            <span class="stat-name">ğŸ€ é‹æ°£</span>
                            <span class="stat-desc">å½±éŸ¿éš¨æ©Ÿäº‹ä»¶çµæœ</span>
                            <div class="stat-controls">
                                <button class="stat-btn" onclick="adjustStat('luck', -1)">-</button>
                                <span id="stat-luck" class="stat-value">0</span>
                                <button class="stat-btn" onclick="adjustStat('luck', 1)">+</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- èº«ä¸–èƒŒæ™¯ -->
                <div class="form-group">
                    <label>èº«ä¸–èƒŒæ™¯</label>
                    <select id="char-background">
                        <option value="wanderer">æµæµªè€…ï¼ˆç„¡åˆå§‹é™£ç‡Ÿå‚¾å‘ï¼‰</option>
                        <option value="noble">æ²’è½è²´æ—ï¼ˆç¬¬ä¸€é™£ç‡Ÿ +15ï¼‰</option>
                        <option value="merchant">å•†äººä¹‹å­ï¼ˆç¬¬äºŒé™£ç‡Ÿ +15ï¼‰</option>
                        <option value="temple">ç¥æ®¿å­¤å…’ï¼ˆç¬¬ä¸‰é™£ç‡Ÿ +15ï¼‰</option>
                        <option value="mystery">ç¥ç§˜ä¾†æ­·ï¼ˆéš¨æ©Ÿä¸€é …å±¬æ€§ +3ï¼‰</option>
                    </select>
                </div>

                <!-- æ€§æ ¼ç‰¹è³ª -->
                <div class="form-group">
                    <label>æ€§æ ¼ç‰¹è³ª (å¯é¸1-2å€‹)</label>
                    <div class="checkbox-group" id="char-traits">
                        <label class="checkbox-item"><input type="checkbox" name="trait" value="cautious"><span>è¬¹æ…</span><small>riské¸é …è¼ƒå°‘å‡ºç¾</small></label>
                        <label class="checkbox-item"><input type="checkbox" name="trait" value="reckless"><span>é­¯è½</span><small>riské¸é …è¼ƒå¤šå‡ºç¾</small></label>
                        <label class="checkbox-item"><input type="checkbox" name="trait" value="curious"><span>å¥½å¥‡</span><small>focusé¸é …è¼ƒå¤šå‡ºç¾</small></label>
                        <label class="checkbox-item"><input type="checkbox" name="trait" value="practical"><span>å‹™å¯¦</span><small>normalé¸é …è¼ƒå¤šå‡ºç¾</small></label>
                    </div>
                </div>

                <div style="text-align:center;margin-top:25px;">
                    <button class="start-adventure-btn" onclick="confirmCharacterCreation()">é–‹å§‹å†’éšª</button>
                </div>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        /**
         * Gemini RPG Engine V9 - å‘½é‹ç¹”ç¶²
         * ç‰¹è‰²åŠŸèƒ½ï¼š
         * 1. äººç‰©é—œä¿‚ç¶² (å¯è¦–åŒ– NPC é—œä¿‚)
         * 2. å‘½é‹é»ç³»çµ± (å¹²æ¶‰ NPC é—œä¿‚)
         * 3. æ—¥æ›†ç³»çµ± (æ™‚é–“æµé€)
         * 4. ä¸–ç•Œè§€å±•ç¤º
         * 5. è‡ªå‹•å­˜æª”èˆ‡è®€æª”
         * 6. è§’è‰²å‰µå»ºç³»çµ±
         * 7. NPC ç‹€æ…‹ç³»çµ±
         * 8. å‘½é‹å›æº¯ç³»çµ±
         * 9. æ“²éª°é‡æ“²ç³»çµ±
         * 10. æ•…äº‹æ‘˜è¦å£“ç¸®
         */

        // ============ å…¨åŸŸè¨­å®š ============
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let apiKey = localStorage.getItem('gemini_api_key') || "";

        const CONFIG = {
            colors: {
                bg: '#15171e',
                textPrimary: '#d8d8d0',
                textDim: '#8f919c',
                textGold: '#deb887',
                panelBg: 'rgba(28, 30, 38, 0.94)',
                panelBorder: '#4a4d5e',
                factions: ['#c76b6b', '#7eb58c', '#6b9bc7'],
                relationColors: {
                    love: '#e08090',
                    ally: '#80c090',
                    neutral: '#909090',
                    rival: '#c0a060',
                    enemy: '#c07070'
                }
            },
            getFonts: (mobile) => {
                const s = mobile ? 0.85 : 1;
                return {
                    display: `900 ${Math.round(36*s)}px "Noto Serif TC"`,
                    displayLarge: `900 ${Math.round(44*s)}px "Noto Serif TC"`,
                    body: `400 ${Math.round(19*s)}px "Noto Serif TC"`,
                    ui: `700 ${Math.round(14*s)}px "Noto Serif TC"`,
                    small: `400 ${Math.round(13*s)}px "Noto Serif TC"`
                };
            }
        };

        // ============ éŠæˆ²ç‹€æ…‹ ============
        const STATE = { INIT: 0, LOADING: 1, WORLD_SELECT: 2, WORLD_INTRO: 3, TYPING: 4, CHOICE: 5 };
        let currentState = STATE.INIT;
        let canvasWidth = 0, canvasHeight = 0, isMobile = false, fonts = {};
        let mouseX = 0, mouseY = 0;

        // éŠæˆ²æ•¸æ“š
        let currentWorld = null;
        let factionData = [];
        let storyContext = "";
        let historyLog = [];
        let currentOptions = [];
        let loadingText = "";
        let generatedWorlds = [];

        // éŸ³è¨Š
        let isSoundOn = false, currentAudio = null;

        // ============ æ–°ç³»çµ±ï¼šæ—¥æ›† ============
        const CALENDAR = {
            year: 1,
            season: 0, // 0æ˜¥ 1å¤ 2ç§‹ 3å†¬
            day: 1,
            timeOfDay: 0, // 0æ¸…æ™¨ 1ä¸Šåˆ 2åˆå¾Œ 3é»ƒæ˜ 4å¤œæ™š 5æ·±å¤œ
            seasonNames: ['æ˜¥æœˆ', 'å¤æœˆ', 'ç§‹æœˆ', 'å†¬æœˆ'],
            dayNames: ['åˆä¸€', 'åˆäºŒ', 'åˆä¸‰', 'åˆå››', 'åˆäº”', 'åˆå…­', 'åˆä¸ƒ', 'åˆå…«', 'åˆä¹', 'åˆå',
                       'åä¸€', 'åäºŒ', 'åä¸‰', 'åå››', 'åäº”', 'åå…­', 'åä¸ƒ', 'åå…«', 'åä¹', 'äºŒå',
                       'å»¿ä¸€', 'å»¿äºŒ', 'å»¿ä¸‰', 'å»¿å››', 'å»¿äº”', 'å»¿å…­', 'å»¿ä¸ƒ', 'å»¿å…«', 'å»¿ä¹', 'ä¸‰å'],
            timeNames: ['æ¸…æ™¨', 'ä¸Šåˆ', 'åˆå¾Œ', 'é»ƒæ˜', 'å¤œæ™š', 'æ·±å¤œ'],

            advance(units = 1) {
                for (let i = 0; i < units; i++) {
                    this.timeOfDay++;
                    if (this.timeOfDay >= 6) {
                        this.timeOfDay = 0;
                        this.day++;
                        if (this.day > 30) {
                            this.day = 1;
                            this.season++;
                            if (this.season >= 4) {
                                this.season = 0;
                                this.year++;
                            }
                        }
                    }
                }
                this.updateDisplay();
            },

            getString() {
                return `ç¬¬${this.year}å¹´ ${this.seasonNames[this.season]} ${this.dayNames[this.day-1]}`;
            },

            getTimeString() {
                return this.timeNames[this.timeOfDay];
            },

            updateDisplay() {
                document.getElementById('calendar-date').textContent = this.getString();
                document.getElementById('calendar-time').textContent = this.getTimeString();
            },

            reset() {
                this.year = 1;
                this.season = 0;
                this.day = 1;
                this.timeOfDay = 0;
            }
        };

        // ============ æ–°ç³»çµ±ï¼šå‘½é‹é» ============
        let fatePoints = 0;

        function addFatePoints(amount) {
            fatePoints += amount;
            document.getElementById('fate-value').textContent = fatePoints;
            // é¡¯ç¤ºç²å¾—å‹•ç•«æ•ˆæœ
            if (amount > 0) {
                showFloatingText(`+${amount} å‘½é‹é»`, canvasWidth/2, canvasHeight/2, '#c0a0e0');
            }
        }

        function spendFatePoints(amount) {
            if (fatePoints >= amount) {
                fatePoints -= amount;
                document.getElementById('fate-value').textContent = fatePoints;
                return true;
            }
            return false;
        }

        // ============ æ–°ç³»çµ±ï¼šè‡ªå‹•å­˜æª” ============
        function autoSave() {
            try {
                const saveData = {
                    currentWorld,
                    factionData,
                    npcs,
                    relationships,
                    historyLog: historyLog.slice(-30), // åªä¿ç•™æœ€è¿‘ 30 ç­†
                    calendar: {
                        year: CALENDAR.year,
                        season: CALENDAR.season,
                        day: CALENDAR.day,
                        timeOfDay: CALENDAR.timeOfDay
                    },
                    fatePoints,
                    storyContext,
                    playerCharacter,
                    currentState,
                    currentOptions,
                    timestamp: Date.now()
                };
                localStorage.setItem('rpg_autosave', JSON.stringify(saveData));
                console.log('è‡ªå‹•å­˜æª”å®Œæˆ', new Date().toLocaleTimeString());
            } catch (e) {
                console.warn('è‡ªå‹•å­˜æª”å¤±æ•—:', e);
                if (e.name === 'QuotaExceededError') {
                    showError('å„²å­˜ç©ºé–“ä¸è¶³ï¼Œè«‹æ¸…ç†èˆŠå­˜æª”');
                }
            }
        }

        function loadAutoSave() {
            try {
                const saveStr = localStorage.getItem('rpg_autosave');
                if (!saveStr) return false;

                const saveData = JSON.parse(saveStr);

                // é‚„åŸéŠæˆ²ç‹€æ…‹
                currentWorld = saveData.currentWorld;
                factionData = saveData.factionData || [];
                npcs = saveData.npcs || [];
                relationships = saveData.relationships || [];
                historyLog = saveData.historyLog || [];
                fatePoints = saveData.fatePoints || 0;
                storyContext = saveData.storyContext || '';
                playerCharacter = saveData.playerCharacter || {
                    id: 'player',
                    name: 'æ—…äºº',
                    role: 'å‘½é‹çš„è¦‹è­‰è€…',
                    desc: 'ä½ ï¼Œä¸€å€‹è¸å…¥é€™å€‹ä¸–ç•Œçš„æ—…äººã€‚',
                    faction: -1,
                    x: 0, y: 0,
                    known: true
                };
                currentOptions = saveData.currentOptions || [];

                // é‚„åŸæ—¥æ›†
                if (saveData.calendar) {
                    CALENDAR.year = saveData.calendar.year;
                    CALENDAR.season = saveData.calendar.season;
                    CALENDAR.day = saveData.calendar.day;
                    CALENDAR.timeOfDay = saveData.calendar.timeOfDay;
                }

                // æ›´æ–° UI
                document.getElementById('calendar-display').style.display = 'block';
                document.getElementById('fate-display').style.display = 'flex';
                document.getElementById('fate-value').textContent = fatePoints;
                CALENDAR.updateDisplay();
                updateNPCBadge();

                // æ ¹æ“š currentState æ¢å¾©ç•«é¢
                currentState = saveData.currentState;
                if (currentState === STATE.TYPING || currentState === STATE.CHOICE) {
                    currentState = STATE.CHOICE;
                    generateOptionsUI();
                    // é¡¯ç¤ºæœ€å¾Œçš„åŠ‡æƒ…æ–‡å­—
                    typewriter.text = storyContext;
                    typewriter.idx = storyContext.length;
                    typewriter.done = true;
                }

                showFloatingText('è®€å–å­˜æª”æˆåŠŸ', canvasWidth/2, canvasHeight/2, '#80c090');
                return true;
            } catch (e) {
                console.error('è®€å–å­˜æª”å¤±æ•—:', e);
                return false;
            }
        }

        function checkAutoSave() {
            const saveStr = localStorage.getItem('rpg_autosave');
            if (!saveStr) return;

            try {
                const saveData = JSON.parse(saveStr);
                const timestamp = new Date(saveData.timestamp);
                const worldName = saveData.currentWorld?.name || 'æœªçŸ¥ä¸–ç•Œ';

                // å»ºç«‹ç¢ºèªå°è©±æ¡†
                const overlay = document.createElement('div');
                overlay.className = 'modal-overlay show';
                overlay.id = 'autosave-modal';
                overlay.innerHTML = `
                    <div class="modal-content" style="max-width:450px;text-align:center;">
                        <div class="modal-title">ç™¼ ç¾ æœª å®Œ æˆ çš„ å†’ éšª</div>
                        <div style="color:#a0a5b0;margin-bottom:20px;line-height:1.8;">
                            <p>ä¸–ç•Œï¼š<span style="color:#deb887;">${worldName}</span></p>
                            <p>å­˜æª”æ™‚é–“ï¼š${timestamp.toLocaleString()}</p>
                        </div>
                        <div style="display:flex;gap:15px;justify-content:center;flex-wrap:wrap;">
                            <button class="start-adventure-btn" onclick="continueAutoSave()">ç¹¼çºŒå†’éšª</button>
                            <button class="start-adventure-btn" style="background:linear-gradient(135deg,#4a4a4a,#3a3a3a);color:#d0d0d0;" onclick="startNewGame()">é‡æ–°é–‹å§‹</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(overlay);
            } catch (e) {
                console.error('æª¢æŸ¥å­˜æª”å¤±æ•—:', e);
            }
        }

        function continueAutoSave() {
            const modal = document.getElementById('autosave-modal');
            if (modal) modal.remove();
            loadAutoSave();
        }

        function startNewGame() {
            const modal = document.getElementById('autosave-modal');
            if (modal) modal.remove();
            clearAutoSave();
            if (!apiKey) toggleSettingsModal(true);
            else startWorldGeneration();
        }

        function clearAutoSave() {
            try {
                localStorage.removeItem('rpg_autosave');
                showFloatingText('å­˜æª”å·²æ¸…é™¤', canvasWidth/2, canvasHeight/2, '#c07070');
            } catch (e) {
                console.warn('æ¸…é™¤å­˜æª”å¤±æ•—:', e);
            }
        }

        // é›¢é–‹é é¢å‰è‡ªå‹•å­˜æª”
        window.addEventListener('beforeunload', () => {
            if (currentState >= STATE.TYPING && currentWorld) {
                autoSave();
            }
        });

        // ============ æ–°ç³»çµ±ï¼šå­˜æª”é»èˆ‡å‘½é‹å›æº¯ ============
        let savePoints = [];
        const MAX_SAVE_POINTS = 50;
        let lastSavePointDay = -1;

        function createSavePoint(name, isMajor = false) {
            const snapshot = {
                currentWorld: JSON.parse(JSON.stringify(currentWorld)),
                factionData: JSON.parse(JSON.stringify(factionData)),
                npcs: JSON.parse(JSON.stringify(npcs)),
                relationships: JSON.parse(JSON.stringify(relationships)),
                historyLog: JSON.parse(JSON.stringify(historyLog)),
                calendar: {
                    year: CALENDAR.year,
                    season: CALENDAR.season,
                    day: CALENDAR.day,
                    timeOfDay: CALENDAR.timeOfDay
                },
                fatePoints,
                storyContext,
                playerCharacter: JSON.parse(JSON.stringify(playerCharacter)),
                currentOptions: JSON.parse(JSON.stringify(currentOptions))
            };

            const savePoint = {
                id: `sp_${Date.now()}`,
                name: name || `${CALENDAR.getString()} - ${storyContext.slice(0, 10)}...`,
                timestamp: Date.now(),
                calendarString: `${CALENDAR.getString()} ${CALENDAR.getTimeString()}`,
                snapshot,
                isMajor
            };

            savePoints.push(savePoint);

            // è¶…éä¸Šé™æ™‚åˆªé™¤æœ€èˆŠçš„éé‡å¤§ç¯€é»
            while (savePoints.length > MAX_SAVE_POINTS) {
                const nonMajorIndex = savePoints.findIndex(sp => !sp.isMajor);
                if (nonMajorIndex >= 0) {
                    savePoints.splice(nonMajorIndex, 1);
                } else {
                    // å…¨éƒ½æ˜¯é‡å¤§ç¯€é»ï¼Œåˆªé™¤æœ€èˆŠçš„
                    savePoints.shift();
                }
            }

            // å„²å­˜åˆ° localStorage
            saveSavePointsToStorage();

            console.log(`å­˜æª”é»å»ºç«‹ï¼š${savePoint.name} (${isMajor ? 'é‡å¤§' : 'æ™®é€š'})`);
        }

        function saveSavePointsToStorage() {
            try {
                localStorage.setItem('rpg_savepoints', JSON.stringify(savePoints));
            } catch (e) {
                console.warn('å­˜æª”é»å„²å­˜å¤±æ•—:', e);
                // å¦‚æœå„²å­˜ç©ºé–“ä¸è¶³ï¼Œåˆªé™¤ä¸€äº›èˆŠçš„å­˜æª”é»
                if (e.name === 'QuotaExceededError' && savePoints.length > 10) {
                    savePoints = savePoints.slice(-10);
                    try {
                        localStorage.setItem('rpg_savepoints', JSON.stringify(savePoints));
                    } catch (e2) {
                        console.error('å­˜æª”é»å„²å­˜ä»ç„¶å¤±æ•—');
                    }
                }
            }
        }

        function loadSavePointsFromStorage() {
            try {
                const data = localStorage.getItem('rpg_savepoints');
                if (data) {
                    savePoints = JSON.parse(data);
                }
            } catch (e) {
                console.warn('è®€å–å­˜æª”é»å¤±æ•—:', e);
                savePoints = [];
            }
        }

        function checkAndCreateSavePoint(triggerType, eventName = '') {
            // triggerType: 'risk', 'fate', 'newNPC', 'monthly'
            let isMajor = false;
            let name = '';

            switch (triggerType) {
                case 'risk':
                    name = `${CALENDAR.getString()} - å†’éšªæŠ‰æ“‡`;
                    break;
                case 'fate':
                    name = `${CALENDAR.getString()} - ${eventName || 'å‘½é‹äº‹ä»¶'}`;
                    isMajor = true;
                    break;
                case 'newNPC':
                    name = `${CALENDAR.getString()} - é‡è¦‹${eventName}`;
                    break;
                case 'monthly':
                    const totalDays = (CALENDAR.year - 1) * 120 + CALENDAR.season * 30 + CALENDAR.day;
                    if (Math.floor(totalDays / 30) !== Math.floor(lastSavePointDay / 30)) {
                        name = `${CALENDAR.getString()} - æœˆæœ«ç´€éŒ„`;
                        lastSavePointDay = totalDays;
                    } else {
                        return; // æœ¬æœˆå·²æœ‰å­˜æª”é»
                    }
                    break;
            }

            if (name) {
                createSavePoint(name, isMajor);
            }
        }

        function revertToSavePoint(savePointId) {
            const savePoint = savePoints.find(sp => sp.id === savePointId);
            if (!savePoint) {
                showError('å­˜æª”é»ä¸å­˜åœ¨');
                return;
            }

            // è¨ˆç®—æ¶ˆè€—
            const cost = savePoint.isMajor ? 8 : 5;
            if (fatePoints < cost) {
                showError(`å‘½é‹é»ä¸è¶³ï¼ˆéœ€è¦ ${cost} é»ï¼‰`);
                return;
            }

            // ç¢ºèªå°è©±æ¡†
            if (!confirm(`å›æº¯å°‡æŠ¹é™¤æ­¤ç¯€é»ä¹‹å¾Œçš„æ‰€æœ‰è¨˜æ†¶ï¼Œæ¶ˆè€— ${cost} å‘½é‹é»ã€‚æ˜¯å¦ç¢ºå®šï¼Ÿ`)) {
                return;
            }

            // æ‰£é™¤å‘½é‹é»
            spendFatePoints(cost);

            // é‚„åŸç‹€æ…‹
            const snapshot = savePoint.snapshot;
            currentWorld = snapshot.currentWorld;
            factionData = snapshot.factionData;
            npcs = snapshot.npcs;
            relationships = snapshot.relationships;
            historyLog = snapshot.historyLog;
            CALENDAR.year = snapshot.calendar.year;
            CALENDAR.season = snapshot.calendar.season;
            CALENDAR.day = snapshot.calendar.day;
            CALENDAR.timeOfDay = snapshot.calendar.timeOfDay;
            fatePoints = snapshot.fatePoints;
            storyContext = snapshot.storyContext;
            playerCharacter = snapshot.playerCharacter;
            currentOptions = snapshot.currentOptions;

            // åˆªé™¤è©²ç¯€é»ä¹‹å¾Œçš„å­˜æª”é»
            const index = savePoints.findIndex(sp => sp.id === savePointId);
            if (index >= 0) {
                savePoints = savePoints.slice(0, index + 1);
            }

            // åˆªé™¤è©²æ™‚é–“é»ä¹‹å¾Œçš„æ­·å²è¨˜éŒ„ï¼ˆé€éæ™‚é–“æˆ³åˆ¤æ–·ï¼‰
            historyLog.push({
                role: 'Fate',
                text: `ã€å‘½é‹å›æº¯ã€‘æ™‚é–“å€’æµè‡³ã€Œ${savePoint.name}ã€`
            });

            // æ›´æ–° UI
            CALENDAR.updateDisplay();
            document.getElementById('fate-value').textContent = fatePoints;
            updateNPCBadge();
            saveSavePointsToStorage();

            // é—œé–‰æ¨¡æ…‹è¦–çª—
            toggleTimelineModal(false);

            // é¡¯ç¤ºéå ´æ•ˆæœ
            showFloatingText('å‘½é‹ä¹‹è¼ªé€†è½‰...', canvasWidth/2, canvasHeight/2, '#c0a0e0');

            // å›åˆ°é¸æ“‡ç‹€æ…‹
            currentState = STATE.CHOICE;
            generateOptionsUI();
            typewriter.text = storyContext;
            typewriter.idx = storyContext.length;
            typewriter.done = true;
        }

        function toggleTimelineModal(show) {
            document.getElementById('timeline-modal').classList.toggle('show', show);
            if (show) {
                renderTimeline();
            }
        }

        function renderTimeline() {
            const container = document.getElementById('timeline-content');

            if (savePoints.length === 0) {
                container.innerHTML = '<div class="timeline-empty">å°šç„¡å‘½é‹ç¯€é»</div>';
                return;
            }

            let html = '';
            for (let i = 0; i < savePoints.length; i++) {
                const sp = savePoints[i];
                const cost = sp.isMajor ? 8 : 5;
                const canRevert = fatePoints >= cost;

                html += `
                    <div class="timeline-item ${sp.isMajor ? 'major' : ''}" onclick="toggleTimelineDetail('${sp.id}')">
                        <div class="timeline-date">${sp.calendarString}</div>
                        <div class="timeline-name">${sp.isMajor ? 'â˜… ' : ''}${sp.name}</div>
                        <div class="timeline-detail" id="detail-${sp.id}">
                            <div class="timeline-detail-row">
                                <span>NPCæ•¸é‡</span>
                                <span>${sp.snapshot.npcs.length}</span>
                            </div>
                            <div class="timeline-detail-row">
                                <span>å‘½é‹é»</span>
                                <span>${sp.snapshot.fatePoints}</span>
                            </div>
                            <div class="timeline-detail-row">
                                <span>é™£ç‡Ÿè²æœ›</span>
                                <span>${sp.snapshot.factionData.map(f => f.rep).join('/')}</span>
                            </div>
                            <button class="timeline-revert-btn" onclick="event.stopPropagation();revertToSavePoint('${sp.id}')" ${canRevert ? '' : 'disabled'}>
                                â³ å›æº¯è‡³æ­¤ <span class="timeline-cost">(æ¶ˆè€— ${cost} å‘½é‹é»)</span>
                            </button>
                        </div>
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        function toggleTimelineDetail(id) {
            const detail = document.getElementById(`detail-${id}`);
            const allDetails = document.querySelectorAll('.timeline-detail');

            allDetails.forEach(d => {
                if (d.id !== `detail-${id}`) {
                    d.classList.remove('show');
                    d.parentElement.classList.remove('selected');
                }
            });

            detail.classList.toggle('show');
            detail.parentElement.classList.toggle('selected');
        }

        // ============ æ–°ç³»çµ±ï¼šå‘½é‹é»é‡æ“²ç³»çµ± ============
        const DICE_REROLL_COST = 3;
        let currentDiceCheck = null;
        let diceCheckCallback = null;

        const STAT_NAMES = {
            strength: 'åŠ›é‡',
            wisdom: 'æ™ºæ…§',
            charisma: 'é­…åŠ›',
            luck: 'é‹æ°£'
        };

        function calculateDiceThreshold(difficulty, statValue) {
            // åŸºç¤é›£åº¦ - å±¬æ€§åŠ æˆ
            // é›£åº¦ï¼šeasy(6), normal(8), hard(10), extreme(12)
            const baseDifficulty = {
                easy: 6,
                normal: 8,
                hard: 10,
                extreme: 12
            };
            const threshold = (baseDifficulty[difficulty] || 8) - Math.floor(statValue / 2);
            return Math.max(2, Math.min(12, threshold)); // æœ€ä½2ï¼Œæœ€é«˜12
        }

        function rollD12() {
            return Math.floor(Math.random() * 12) + 1;
        }

        async function performDiceCheck(title, stat, difficulty, onComplete) {
            const statValue = playerCharacter.stats[stat] || 0;
            const threshold = calculateDiceThreshold(difficulty, statValue);

            currentDiceCheck = {
                title,
                stat,
                difficulty,
                threshold,
                statValue,
                result: null,
                success: false,
                rerolled: false
            };

            diceCheckCallback = onComplete;

            // é¡¯ç¤º UI
            document.getElementById('dice-title').textContent = title;
            document.getElementById('dice-attribute').textContent = `${STAT_NAMES[stat] || stat} æª¢å®š`;
            document.getElementById('dice-threshold').textContent = `ç›®æ¨™ï¼š${threshold} ä»¥ä¸Š`;
            document.getElementById('dice-stat-bonus').textContent = statValue > 0 ? `(${STAT_NAMES[stat]} ${statValue} â†’ é›£åº¦ -${Math.floor(statValue/2)})` : '';
            document.getElementById('dice-result-text').classList.remove('show', 'success', 'failure');
            document.getElementById('dice-reroll-section').classList.remove('show');
            document.getElementById('dice-display').textContent = '?';
            document.getElementById('dice-display').classList.remove('success', 'failure', 'rolling');

            document.getElementById('dice-overlay').classList.add('show');

            // é–‹å§‹æ“²éª°å‹•ç•«
            await animateDiceRoll();
        }

        async function animateDiceRoll() {
            const display = document.getElementById('dice-display');
            display.classList.add('rolling');

            // æ»¾å‹•å‹•ç•«
            for (let i = 0; i < 15; i++) {
                display.textContent = rollD12();
                await sleep(80 + i * 10);
            }

            display.classList.remove('rolling');

            // æœ€çµ‚çµæœ
            const finalResult = rollD12();
            display.textContent = finalResult;

            currentDiceCheck.result = finalResult;
            currentDiceCheck.success = finalResult >= currentDiceCheck.threshold;

            // é¡¯ç¤ºçµæœ
            await sleep(300);

            const resultText = document.getElementById('dice-result-text');
            if (currentDiceCheck.success) {
                display.classList.add('success');
                resultText.textContent = 'æˆåŠŸï¼';
                resultText.classList.add('success');
            } else {
                display.classList.add('failure');
                resultText.textContent = 'å¤±æ•—...';
                resultText.classList.add('failure');
            }
            resultText.classList.add('show');

            // é¡¯ç¤ºé‡æ“²é¸é …
            await sleep(500);
            const rerollSection = document.getElementById('dice-reroll-section');
            const rerollBtn = document.getElementById('dice-reroll-btn');

            // åªæœ‰å¤±æ•—ä¸”æœ‰è¶³å¤ å‘½é‹é»æ‰èƒ½é‡æ“²
            const canReroll = !currentDiceCheck.success && fatePoints >= DICE_REROLL_COST && !currentDiceCheck.rerolled;
            rerollBtn.disabled = !canReroll;
            rerollBtn.textContent = canReroll ? `âœ§ å‘½é‹ä»‹å…¥ (${DICE_REROLL_COST}é»)` : (currentDiceCheck.rerolled ? 'å·²ä½¿ç”¨å‘½é‹ä»‹å…¥' : `å‘½é‹é»ä¸è¶³ (éœ€${DICE_REROLL_COST}é»)`);

            rerollSection.classList.add('show');
        }

        async function rerollDice() {
            if (!currentDiceCheck || currentDiceCheck.rerolled || fatePoints < DICE_REROLL_COST) return;

            // æ‰£é™¤å‘½é‹é»
            spendFatePoints(DICE_REROLL_COST);
            currentDiceCheck.rerolled = true;

            // é‡ç½® UI
            const display = document.getElementById('dice-display');
            const resultText = document.getElementById('dice-result-text');
            display.classList.remove('success', 'failure');
            resultText.classList.remove('show', 'success', 'failure');
            document.getElementById('dice-reroll-section').classList.remove('show');

            showFloatingText('å‘½é‹ä¹‹è¼ªè½‰å‹•...', canvasWidth/2, canvasHeight/2, '#c0a0e0');

            // é‹æ°£å±¬æ€§å½±éŸ¿é‡æ“²ï¼šé‹æ°£æ¯é»å¢åŠ  5% æˆåŠŸç‡ï¼ˆé€šéé™ä½é›£åº¦ï¼‰
            const luckBonus = playerCharacter.stats.luck || 0;
            const adjustedThreshold = Math.max(2, currentDiceCheck.threshold - Math.floor(luckBonus / 3));
            currentDiceCheck.threshold = adjustedThreshold;

            document.getElementById('dice-threshold').textContent = `ç›®æ¨™ï¼š${adjustedThreshold} ä»¥ä¸Š`;
            if (luckBonus > 0) {
                document.getElementById('dice-stat-bonus').textContent += ` (é‹æ°£ä»‹å…¥ â†’ é›£åº¦ -${Math.floor(luckBonus/3)})`;
            }

            // é‡æ–°æ“²éª°
            await sleep(500);
            await animateDiceRoll();
        }

        function continueDiceResult() {
            const overlay = document.getElementById('dice-overlay');
            overlay.classList.remove('show');

            if (diceCheckCallback) {
                diceCheckCallback(currentDiceCheck);
                diceCheckCallback = null;
            }

            currentDiceCheck = null;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // ============ æ–°ç³»çµ±ï¼šNPC ç‹€æ…‹ ============
        const NPC_STATUS = {
            ACTIVE: 'active',        // æ­£å¸¸æ´»èº
            INJURED: 'injured',      // å—å‚·
            MISSING: 'missing',      // å¤±è¹¤
            IMPRISONED: 'imprisoned', // è¢«å›šç¦
            BETRAYED: 'betrayed',    // å·²èƒŒå›
            DEAD: 'dead'             // æ­»äº¡
        };

        const NPC_STATUS_INFO = {
            active: { name: 'æ´»èº', color: '#80c090', desc: 'æ­£å¸¸æ´»å‹•ä¸­' },
            injured: { name: 'å—å‚·', color: '#c07070', desc: 'å› å‚·éœ€è¦ä¼‘é¤Š' },
            missing: { name: 'å¤±è¹¤', color: '#a0a0a0', desc: 'ä¸‹è½ä¸æ˜' },
            imprisoned: { name: 'è¢«å›š', color: '#7070a0', desc: 'è¢«é—œæŠ¼ä¸­' },
            betrayed: { name: 'èƒŒå›', color: '#a060c0', desc: 'å·²ç¶“èƒŒå›äº†ä½ ' },
            dead: { name: 'æ­»äº¡', color: '#505050', desc: 'å·²ç¶“é›¢é–‹äººä¸–' }
        };

        // ============ æ–°ç³»çµ±ï¼šNPC èˆ‡é—œä¿‚ç¶² ============
        let playerCharacter = {
            id: 'player',
            name: 'æ—…äºº',
            role: 'å‘½é‹çš„è¦‹è­‰è€…',
            desc: 'ä½ ï¼Œä¸€å€‹è¸å…¥é€™å€‹ä¸–ç•Œçš„æ—…äººã€‚',
            faction: -1,
            x: 0, y: 0, // é—œä¿‚ç¶²ä¸­çš„ä½ç½®
            known: true,
            // è§’è‰²å‰µå»ºæ“´å±•å±¬æ€§
            gender: 'ä¸æŒ‡å®š',
            stats: {
                strength: 0,
                wisdom: 0,
                charisma: 0,
                luck: 0
            },
            background: 'wanderer',
            traits: []
        };

        // ============ è§’è‰²å‰µå»ºç³»çµ± ============
        let tempStats = { strength: 0, wisdom: 0, charisma: 0, luck: 0 };
        let statPointsRemaining = 10;

        const BACKGROUND_INFO = {
            wanderer: { name: 'æµæµªè€…', desc: 'ç„¡åˆå§‹é™£ç‡Ÿå‚¾å‘', factionBonus: -1 },
            noble: { name: 'æ²’è½è²´æ—', desc: 'ç¬¬ä¸€é™£ç‡Ÿ +15', factionBonus: 0 },
            merchant: { name: 'å•†äººä¹‹å­', desc: 'ç¬¬äºŒé™£ç‡Ÿ +15', factionBonus: 1 },
            temple: { name: 'ç¥æ®¿å­¤å…’', desc: 'ç¬¬ä¸‰é™£ç‡Ÿ +15', factionBonus: 2 },
            mystery: { name: 'ç¥ç§˜ä¾†æ­·', desc: 'éš¨æ©Ÿå±¬æ€§ +3', factionBonus: -1 }
        };

        const TRAIT_INFO = {
            cautious: { name: 'è¬¹æ…', effect: 'riské¸é …è¼ƒå°‘' },
            reckless: { name: 'é­¯è½', effect: 'riské¸é …è¼ƒå¤š' },
            curious: { name: 'å¥½å¥‡', effect: 'focusé¸é …è¼ƒå¤š' },
            practical: { name: 'å‹™å¯¦', effect: 'normalé¸é …è¼ƒå¤š' }
        };

        function adjustStat(stat, delta) {
            const newValue = tempStats[stat] + delta;

            if (newValue < 0) return;
            if (delta > 0 && statPointsRemaining <= 0) return;
            if (newValue > 10) return;

            tempStats[stat] = newValue;
            statPointsRemaining -= delta;

            document.getElementById(`stat-${stat}`).textContent = newValue;
            document.getElementById('stat-points-remaining').textContent = `(å‰©é¤˜é»æ•¸: ${statPointsRemaining})`;
        }

        function resetCharacterForm() {
            tempStats = { strength: 0, wisdom: 0, charisma: 0, luck: 0 };
            statPointsRemaining = 10;

            document.getElementById('char-name').value = '';
            document.querySelectorAll('input[name="gender"]')[0].checked = true;
            document.getElementById('char-background').value = 'wanderer';
            document.querySelectorAll('input[name="trait"]').forEach(cb => cb.checked = false);

            ['strength', 'wisdom', 'charisma', 'luck'].forEach(stat => {
                document.getElementById(`stat-${stat}`).textContent = '0';
            });
            document.getElementById('stat-points-remaining').textContent = '(å‰©é¤˜é»æ•¸: 10)';
        }

        function toggleCharacterCreateModal(show) {
            document.getElementById('character-create-modal').classList.toggle('show', show);
            if (show) resetCharacterForm();
        }

        function confirmCharacterCreation() {
            // ç²å–å§“å
            const name = document.getElementById('char-name').value.trim() || 'ç„¡åæ—…äºº';

            // ç²å–æ€§åˆ¥
            const gender = document.querySelector('input[name="gender"]:checked').value;

            // ç²å–èº«ä¸–èƒŒæ™¯
            const background = document.getElementById('char-background').value;

            // ç²å–æ€§æ ¼ç‰¹è³ªï¼ˆæœ€å¤š2å€‹ï¼‰
            const traitCheckboxes = document.querySelectorAll('input[name="trait"]:checked');
            const traits = Array.from(traitCheckboxes).slice(0, 2).map(cb => cb.value);

            // è™•ç†ç¥ç§˜ä¾†æ­·çš„éš¨æ©Ÿå±¬æ€§åŠ æˆ
            let finalStats = { ...tempStats };
            if (background === 'mystery') {
                const statKeys = ['strength', 'wisdom', 'charisma', 'luck'];
                const randomStat = statKeys[Math.floor(Math.random() * statKeys.length)];
                finalStats[randomStat] += 3;
                showFloatingText(`ç¥ç§˜åŠ›é‡è¦ºé†’ï¼š${randomStat === 'strength' ? 'åŠ›é‡' : randomStat === 'wisdom' ? 'æ™ºæ…§' : randomStat === 'charisma' ? 'é­…åŠ›' : 'é‹æ°£'} +3`, canvasWidth/2, canvasHeight/2, '#c0a0e0');
            }

            // æ›´æ–° playerCharacter
            playerCharacter.name = name;
            playerCharacter.gender = gender;
            playerCharacter.stats = finalStats;
            playerCharacter.background = background;
            playerCharacter.traits = traits;
            playerCharacter.desc = `${name}ï¼Œ${gender}ï¼Œ${BACKGROUND_INFO[background].name}å‡ºèº«ã€‚`;

            // é—œé–‰æ¨¡æ…‹è¦–çª—
            toggleCharacterCreateModal(false);

            // é–‹å§‹å†’éšª
            startAdventureWithCharacter();
        }

        function getCharacterPromptString() {
            const bg = BACKGROUND_INFO[playerCharacter.background];
            const traitsStr = playerCharacter.traits.map(t => TRAIT_INFO[t]?.name).filter(Boolean).join('ã€') || 'ç„¡';

            return `ä¸»è§’ï¼š${playerCharacter.name}ï¼Œ${playerCharacter.gender}ï¼Œ${bg.name}ã€‚æ€§æ ¼ï¼š${traitsStr}ã€‚å±¬æ€§ï¼šåŠ›é‡${playerCharacter.stats.strength}/æ™ºæ…§${playerCharacter.stats.wisdom}/é­…åŠ›${playerCharacter.stats.charisma}/é‹æ°£${playerCharacter.stats.luck}`;
        }

        function getTraitOptionModifiers() {
            // æ ¹æ“šæ€§æ ¼ç‰¹è³ªè¿”å›é¸é …é¡å‹çš„æ¬Šé‡èª¿æ•´
            const modifiers = { risk: 1, focus: 1, normal: 1 };

            for (const trait of playerCharacter.traits) {
                switch (trait) {
                    case 'cautious': modifiers.risk *= 0.5; break;
                    case 'reckless': modifiers.risk *= 1.5; break;
                    case 'curious': modifiers.focus *= 1.5; break;
                    case 'practical': modifiers.normal *= 1.5; break;
                }
            }

            return modifiers;
        }

        let npcs = []; // NPC åˆ—è¡¨
        let relationships = []; // é—œä¿‚åˆ—è¡¨ { from, to, type, strength, revealed }

        const RELATION_TYPES = {
            love: { name: 'æ„›æ…•', color: '#e08090', cost: 8 },
            ally: { name: 'ç›Ÿå‹', color: '#80c090', cost: 5 },
            neutral: { name: 'ä¸­ç«‹', color: '#909090', cost: 3 },
            rival: { name: 'ç«¶çˆ­', color: '#c0a060', cost: 5 },
            enemy: { name: 'æ•µå°', color: '#c07070', cost: 8 }
        };

        function addNPC(npc) {
            if (!npcs.find(n => n.id === npc.id)) {
                npc.known = true;
                npc.status = npc.status || NPC_STATUS.ACTIVE;
                npc.x = Math.random() * 300 - 150;
                npc.y = Math.random() * 300 - 150;
                npcs.push(npc);
                updateNPCBadge();
                showFloatingText(`é‡è¦‹äº† ${npc.name}`, canvasWidth/2, 100, '#d4c4a0');
            }
        }

        function updateNPCStatus(npcId, newStatus, reason) {
            const npc = npcs.find(n => n.id === npcId);
            if (npc && npc.status !== newStatus) {
                const oldStatus = npc.status;
                npc.status = newStatus;
                const statusInfo = NPC_STATUS_INFO[newStatus];
                showFloatingText(`${npc.name} ${statusInfo.name}`, canvasWidth/2, canvasHeight/2, statusInfo.color);
                historyLog.push({
                    role: 'Status',
                    text: `ã€ç‹€æ…‹è®Šæ›´ã€‘${npc.name}ï¼š${NPC_STATUS_INFO[oldStatus]?.name || 'æœªçŸ¥'} â†’ ${statusInfo.name}${reason ? `ï¼ˆ${reason}ï¼‰` : ''}`
                });
            }
        }

        function addRelationship(fromId, toId, type, revealed = false) {
            const existing = relationships.find(r => 
                (r.from === fromId && r.to === toId) || (r.from === toId && r.to === fromId)
            );
            if (!existing) {
                relationships.push({ from: fromId, to: toId, type, revealed });
            }
        }

        function revealRelationship(fromId, toId) {
            const rel = relationships.find(r => 
                (r.from === fromId && r.to === toId) || (r.from === toId && r.to === fromId)
            );
            if (rel && !rel.revealed) {
                rel.revealed = true;
                return true;
            }
            return false;
        }

        function modifyRelationship(fromId, toId, newType) {
            const rel = relationships.find(r => 
                (r.from === fromId && r.to === toId) || (r.from === toId && r.to === fromId)
            );
            if (rel) {
                rel.type = newType;
                return true;
            }
            return false;
        }

        function updateNPCBadge() {
            const badge = document.getElementById('npc-count');
            if (npcs.length > 0) {
                badge.textContent = npcs.length;
                badge.style.display = 'flex';
            } else {
                badge.style.display = 'none';
            }
        }

        // ============ é—œä¿‚ç¶²è¦–è¦ºåŒ– ============
        let relationCanvas, relationCtx;
        let selectedNPC = null;
        let relationDragging = null;
        let relationOffset = { x: 0, y: 0 };

        function initRelationCanvas() {
            relationCanvas = document.getElementById('relationCanvas');
            relationCtx = relationCanvas.getContext('2d');
            
            const rect = relationCanvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            relationCanvas.width = rect.width * dpr;
            relationCanvas.height = rect.height * dpr;
            relationCtx.scale(dpr, dpr);

            // äº‹ä»¶
            relationCanvas.addEventListener('mousedown', onRelationMouseDown);
            relationCanvas.addEventListener('mousemove', onRelationMouseMove);
            relationCanvas.addEventListener('mouseup', onRelationMouseUp);
            relationCanvas.addEventListener('touchstart', onRelationTouchStart, { passive: false });
            relationCanvas.addEventListener('touchmove', onRelationTouchMove, { passive: false });
            relationCanvas.addEventListener('touchend', onRelationTouchEnd, { passive: false });
        }

        function getRelationCanvasCoords(e) {
            const rect = relationCanvas.getBoundingClientRect();
            const x = (e.clientX || e.touches?.[0]?.clientX) - rect.left;
            const y = (e.clientY || e.touches?.[0]?.clientY) - rect.top;
            return { x, y };
        }

        function findNodeAt(x, y) {
            const centerX = relationCanvas.width / (window.devicePixelRatio || 1) / 2;
            const centerY = relationCanvas.height / (window.devicePixelRatio || 1) / 2;

            // æª¢æŸ¥ç©å®¶
            const px = centerX + playerCharacter.x;
            const py = centerY + playerCharacter.y;
            if (Math.hypot(x - px, y - py) < 35) return playerCharacter;

            // æª¢æŸ¥ NPC
            for (const npc of npcs) {
                const nx = centerX + npc.x;
                const ny = centerY + npc.y;
                if (Math.hypot(x - nx, y - ny) < 30) return npc;
            }
            return null;
        }

        function onRelationMouseDown(e) {
            const { x, y } = getRelationCanvasCoords(e);
            const node = findNodeAt(x, y);
            if (node) {
                relationDragging = node;
                const centerX = relationCanvas.width / (window.devicePixelRatio || 1) / 2;
                const centerY = relationCanvas.height / (window.devicePixelRatio || 1) / 2;
                relationOffset.x = x - (centerX + node.x);
                relationOffset.y = y - (centerY + node.y);
            }
        }

        function onRelationMouseMove(e) {
            const { x, y } = getRelationCanvasCoords(e);
            if (relationDragging) {
                const centerX = relationCanvas.width / (window.devicePixelRatio || 1) / 2;
                const centerY = relationCanvas.height / (window.devicePixelRatio || 1) / 2;
                relationDragging.x = x - centerX - relationOffset.x;
                relationDragging.y = y - centerY - relationOffset.y;
                drawRelationNetwork();
            }
        }

        function onRelationMouseUp(e) {
            if (relationDragging) {
                const { x, y } = getRelationCanvasCoords(e);
                const node = findNodeAt(x, y);
                if (node && node === relationDragging) {
                    selectNPC(node);
                }
                relationDragging = null;
            }
        }

        function onRelationTouchStart(e) {
            e.preventDefault();
            onRelationMouseDown(e);
        }

        function onRelationTouchMove(e) {
            e.preventDefault();
            onRelationMouseMove(e);
        }

        function onRelationTouchEnd(e) {
            e.preventDefault();
            onRelationMouseUp(e);
        }

        function selectNPC(node) {
            selectedNPC = node;
            showNPCDetail(node);
        }

        function showNPCDetail(node) {
            const panel = document.getElementById('npc-detail');
            if (!node) {
                panel.classList.remove('show');
                return;
            }

            const isPlayer = node.id === 'player';
            const status = node.status || NPC_STATUS.ACTIVE;
            const statusInfo = NPC_STATUS_INFO[status];

            let statusHtml = '';
            if (!isPlayer && status !== NPC_STATUS.ACTIVE) {
                statusHtml = `<div style="margin-top:10px;padding:8px 12px;background:rgba(0,0,0,0.3);border-radius:6px;border-left:3px solid ${statusInfo.color};">
                    <span style="color:${statusInfo.color};font-weight:700;">ã€${statusInfo.name}ã€‘</span>
                    <span style="color:#8a8d9a;">${statusInfo.desc}</span>
                </div>`;
            }

            let html = `
                <h3>${node.name}</h3>
                <div class="role">${node.role}</div>
                <div class="desc">${node.desc}</div>
                ${statusHtml}
            `;

            // é¡¯ç¤ºé—œä¿‚
            const nodeRelations = relationships.filter(r => 
                (r.from === node.id || r.to === node.id) && r.revealed
            );

            if (nodeRelations.length > 0) {
                html += `<div class="relations"><strong style="color:#7a7d8a;">å·²çŸ¥é—œä¿‚ï¼š</strong>`;
                for (const rel of nodeRelations) {
                    const otherId = rel.from === node.id ? rel.to : rel.from;
                    const other = otherId === 'player' ? playerCharacter : npcs.find(n => n.id === otherId);
                    if (other) {
                        const typeInfo = RELATION_TYPES[rel.type];
                        html += `
                            <div class="relation-item">
                                <span class="target">${other.name}</span>
                                <span class="status ${rel.type}">${typeInfo.name}</span>
                            </div>
                        `;
                    }
                }
                html += `</div>`;
            }

            // å‘½é‹å¹²æ¶‰æŒ‰éˆ•ï¼ˆéç©å®¶ï¼‰
            if (!isPlayer) {
                const unrevealedRels = relationships.filter(r => 
                    (r.from === node.id || r.to === node.id) && !r.revealed
                );

                if (unrevealedRels.length > 0) {
                    html += `
                        <button class="fate-action-btn" onclick="revealRandomRelation('${node.id}')" ${fatePoints < 3 ? 'disabled' : ''}>
                            âœ§ çªºè¦–å‘½é‹ä¹‹ç·š <span class="cost">(æ¶ˆè€— 3 å‘½é‹é»)</span>
                        </button>
                    `;
                }

                // ä¿®æ”¹é—œä¿‚çš„é¸é …
                const revealedRels = relationships.filter(r => 
                    (r.from === node.id || r.to === node.id) && r.revealed
                );

                if (revealedRels.length > 0) {
                    html += `<div style="margin-top:15px;">`;
                    for (const rel of revealedRels) {
                        const otherId = rel.from === node.id ? rel.to : rel.from;
                        const other = otherId === 'player' ? playerCharacter : npcs.find(n => n.id === otherId);
                        if (other && otherId !== 'player') {
                            html += `
                                <button class="fate-action-btn" onclick="openModifyRelation('${node.id}', '${otherId}')" ${fatePoints < 5 ? 'disabled' : ''}>
                                    âœ§ å¹²æ¶‰èˆ‡${other.name}çš„ç¾ˆçµ† <span class="cost">(æ¶ˆè€— 5+ å‘½é‹é»)</span>
                                </button>
                            `;
                        }
                    }
                    html += `</div>`;
                }
            }

            panel.innerHTML = html;
            panel.classList.add('show');
        }

        function revealRandomRelation(nodeId) {
            if (!spendFatePoints(3)) {
                showError("å‘½é‹é»ä¸è¶³");
                return;
            }

            const unrevealedRels = relationships.filter(r => 
                (r.from === nodeId || r.to === nodeId) && !r.revealed
            );

            if (unrevealedRels.length > 0) {
                const rel = unrevealedRels[Math.floor(Math.random() * unrevealedRels.length)];
                rel.revealed = true;
                drawRelationNetwork();
                showNPCDetail(selectedNPC);
                showFloatingText("å‘½é‹ä¹‹ç·šé¡¯ç¾...", canvasWidth/2, canvasHeight/2, '#c0a0e0');
            }
        }

        function openModifyRelation(fromId, toId) {
            const fromNPC = npcs.find(n => n.id === fromId);
            const toNPC = npcs.find(n => n.id === toId);
            if (!fromNPC || !toNPC) return;

            const rel = relationships.find(r => 
                (r.from === fromId && r.to === toId) || (r.from === toId && r.to === fromId)
            );
            if (!rel) return;

            let options = '';
            for (const [type, info] of Object.entries(RELATION_TYPES)) {
                if (type !== rel.type) {
                    options += `<button class="fate-action-btn" style="margin:5px;" onclick="executeModifyRelation('${fromId}', '${toId}', '${type}', ${info.cost})" ${fatePoints < info.cost ? 'disabled' : ''}>
                        ${info.name} <span class="cost">(${info.cost}é»)</span>
                    </button>`;
                }
            }

            const panel = document.getElementById('npc-detail');
            panel.innerHTML = `
                <h3>å¹²æ¶‰å‘½é‹</h3>
                <div class="role">æ”¹è®Š ${fromNPC.name} èˆ‡ ${toNPC.name} ä¹‹é–“çš„é—œä¿‚</div>
                <div style="margin-top:20px;">
                    <div style="color:#7a7d8a;margin-bottom:10px;">ç›®å‰é—œä¿‚ï¼š${RELATION_TYPES[rel.type].name}</div>
                    <div>å°‡å…¶è½‰è®Šç‚ºï¼š</div>
                    ${options}
                </div>
                <button class="fate-action-btn" style="margin-top:20px;background:#2a2a3a;" onclick="showNPCDetail(selectedNPC)">å–æ¶ˆ</button>
            `;
        }

        function executeModifyRelation(fromId, toId, newType, cost) {
            if (!spendFatePoints(cost)) {
                showError("å‘½é‹é»ä¸è¶³");
                return;
            }

            modifyRelationship(fromId, toId, newType);
            drawRelationNetwork();
            showNPCDetail(selectedNPC);
            showFloatingText("å‘½é‹å·²è¢«æ”¹å¯«...", canvasWidth/2, canvasHeight/2, '#c0a0e0');

            // åŠ å…¥æ­·å²è¨˜éŒ„
            const fromNPC = npcs.find(n => n.id === fromId);
            const toNPC = npcs.find(n => n.id === toId);
            if (fromNPC && toNPC) {
                historyLog.push({
                    role: 'Fate',
                    text: `å‘½é‹è¢«å¹²æ¶‰ï¼š${fromNPC.name}èˆ‡${toNPC.name}çš„é—œä¿‚è½‰è®Šç‚ºã€Œ${RELATION_TYPES[newType].name}ã€`
                });
            }
        }

        function drawRelationNetwork() {
            if (!relationCtx) return;

            const w = relationCanvas.width / (window.devicePixelRatio || 1);
            const h = relationCanvas.height / (window.devicePixelRatio || 1);
            const centerX = w / 2;
            const centerY = h / 2;

            // æ¸…é™¤
            relationCtx.fillStyle = '#0d0f14';
            relationCtx.fillRect(0, 0, w, h);

            // èƒŒæ™¯ç¶²æ ¼
            relationCtx.strokeStyle = 'rgba(60, 65, 80, 0.15)';
            relationCtx.lineWidth = 1;
            for (let x = 0; x < w; x += 40) {
                relationCtx.beginPath();
                relationCtx.moveTo(x, 0);
                relationCtx.lineTo(x, h);
                relationCtx.stroke();
            }
            for (let y = 0; y < h; y += 40) {
                relationCtx.beginPath();
                relationCtx.moveTo(0, y);
                relationCtx.lineTo(w, y);
                relationCtx.stroke();
            }

            // ç¹ªè£½é—œä¿‚ç·š
            for (const rel of relationships) {
                if (!rel.revealed) continue;

                const fromNode = rel.from === 'player' ? playerCharacter : npcs.find(n => n.id === rel.from);
                const toNode = rel.to === 'player' ? playerCharacter : npcs.find(n => n.id === rel.to);

                if (fromNode && toNode) {
                    const fx = centerX + fromNode.x;
                    const fy = centerY + fromNode.y;
                    const tx = centerX + toNode.x;
                    const ty = centerY + toNode.y;

                    const typeInfo = RELATION_TYPES[rel.type];
                    relationCtx.strokeStyle = typeInfo.color;
                    relationCtx.lineWidth = 2;
                    relationCtx.setLineDash(rel.type === 'enemy' ? [5, 5] : []);

                    relationCtx.beginPath();
                    relationCtx.moveTo(fx, fy);
                    relationCtx.lineTo(tx, ty);
                    relationCtx.stroke();

                    // é—œä¿‚æ¨™ç±¤
                    const mx = (fx + tx) / 2;
                    const my = (fy + ty) / 2;
                    relationCtx.fillStyle = 'rgba(13, 15, 20, 0.8)';
                    relationCtx.fillRect(mx - 20, my - 10, 40, 20);
                    relationCtx.fillStyle = typeInfo.color;
                    relationCtx.font = '12px "Noto Serif TC"';
                    relationCtx.textAlign = 'center';
                    relationCtx.textBaseline = 'middle';
                    relationCtx.fillText(typeInfo.name, mx, my);
                }
            }

            relationCtx.setLineDash([]);

            // ç¹ªè£½ NPC ç¯€é»
            for (const npc of npcs) {
                drawNode(centerX + npc.x, centerY + npc.y, npc, npc === selectedNPC);
            }

            // ç¹ªè£½ç©å®¶ç¯€é»
            drawNode(centerX + playerCharacter.x, centerY + playerCharacter.y, playerCharacter, playerCharacter === selectedNPC, true);
        }

        function drawNode(x, y, node, selected, isPlayer = false) {
            const r = isPlayer ? 35 : 28;
            const status = node.status || NPC_STATUS.ACTIVE;

            // æ ¹æ“šç‹€æ…‹èª¿æ•´é€æ˜åº¦
            const isDead = status === NPC_STATUS.DEAD;
            const isMissing = status === NPC_STATUS.MISSING;
            const isInjured = status === NPC_STATUS.INJURED;
            const isImprisoned = status === NPC_STATUS.IMPRISONED;
            const isBetrayed = status === NPC_STATUS.BETRAYED;

            relationCtx.save();
            if (isDead || isMissing) {
                relationCtx.globalAlpha = isMissing ? 0.5 : 0.4;
            }

            // å…‰æšˆ
            if (selected) {
                const glow = relationCtx.createRadialGradient(x, y, r, x, y, r + 15);
                glow.addColorStop(0, 'rgba(201, 162, 39, 0.4)');
                glow.addColorStop(1, 'rgba(201, 162, 39, 0)');
                relationCtx.fillStyle = glow;
                relationCtx.beginPath();
                relationCtx.arc(x, y, r + 15, 0, Math.PI * 2);
                relationCtx.fill();
            }

            // ç¯€é»èƒŒæ™¯
            const grad = relationCtx.createRadialGradient(x, y - r/2, 0, x, y, r);
            if (isPlayer) {
                grad.addColorStop(0, '#4a4030');
                grad.addColorStop(1, '#2a2520');
            } else if (isDead) {
                grad.addColorStop(0, '#4a4a4a');
                grad.addColorStop(1, '#2a2a2a');
            } else {
                const factionColor = node.faction >= 0 ? CONFIG.colors.factions[node.faction % 3] : '#3a3d4a';
                grad.addColorStop(0, factionColor);
                grad.addColorStop(1, '#1a1c24');
            }

            relationCtx.fillStyle = grad;
            relationCtx.beginPath();
            relationCtx.arc(x, y, r, 0, Math.PI * 2);
            relationCtx.fill();

            // é‚Šæ¡† - æ ¹æ“šç‹€æ…‹æ”¹è®Šé¡è‰²
            let borderColor = selected ? '#c9a227' : (isPlayer ? '#c9a227' : '#5a5d6a');
            if (!isPlayer) {
                if (isInjured) borderColor = '#c07070';
                else if (isBetrayed) borderColor = '#a060c0';
                else if (isImprisoned) borderColor = '#7070a0';
            }
            relationCtx.strokeStyle = borderColor;
            relationCtx.lineWidth = selected ? 3 : 2;
            relationCtx.stroke();

            // è¢«å›šç¦ç‹€æ…‹ï¼šç¹ªè£½æ¢ç´‹æ•ˆæœ
            if (isImprisoned && !isPlayer) {
                relationCtx.strokeStyle = 'rgba(100, 100, 150, 0.5)';
                relationCtx.lineWidth = 2;
                for (let i = -r; i <= r; i += 8) {
                    relationCtx.beginPath();
                    const dx = Math.sqrt(r * r - i * i);
                    relationCtx.moveTo(x + i, y - dx);
                    relationCtx.lineTo(x + i, y + dx);
                    relationCtx.stroke();
                }
            }

            relationCtx.restore();

            // åå­—
            relationCtx.fillStyle = isDead ? '#707070' : '#d0d0c8';
            relationCtx.font = `${isPlayer ? '14' : '12'}px "Noto Serif TC"`;
            relationCtx.textAlign = 'center';
            relationCtx.textBaseline = 'middle';

            let displayName = node.name;
            if (isDead) {
                // åˆªé™¤ç·šæ•ˆæœ
                displayName = node.name;
                relationCtx.fillText(displayName, x, y + r + 18);
                const textWidth = relationCtx.measureText(displayName).width;
                relationCtx.strokeStyle = '#707070';
                relationCtx.lineWidth = 1;
                relationCtx.beginPath();
                relationCtx.moveTo(x - textWidth/2, y + r + 18);
                relationCtx.lineTo(x + textWidth/2, y + r + 18);
                relationCtx.stroke();
            } else {
                relationCtx.fillText(displayName, x, y + r + 18);
            }

            // å¤±è¹¤ç‹€æ…‹ï¼šé¡¯ç¤ºå•è™Ÿ
            if (isMissing && !isPlayer) {
                relationCtx.fillStyle = '#a0a0a0';
                relationCtx.font = '20px "Noto Serif TC"';
                relationCtx.fillText('?', x, y);
            }

            // ç‹€æ…‹åœ–ç¤º
            if (!isPlayer && status !== NPC_STATUS.ACTIVE) {
                const statusInfo = NPC_STATUS_INFO[status];
                if (statusInfo) {
                    relationCtx.fillStyle = statusInfo.color;
                    relationCtx.font = '10px "Noto Serif TC"';
                    relationCtx.fillText(statusInfo.name, x, y + r + 32);
                }
            }
        }

        // ============ API æœå‹™ ============

        // JSON å®¹éŒ¯è§£æå‡½æ•¸
        function tryParseJSON(text) {
            if (!text || typeof text !== 'string') return null;

            // ç­–ç•¥ 1ï¼šç›´æ¥è§£æ
            try {
                return JSON.parse(text);
            } catch (e) {}

            // ç­–ç•¥ 2ï¼šç§»é™¤ markdown çš„ ```json å’Œ ``` åŒ…è£¹
            try {
                let cleaned = text.replace(/^```json\s*/i, '').replace(/^```\s*/i, '').replace(/\s*```$/i, '');
                return JSON.parse(cleaned);
            } catch (e) {}

            // ç­–ç•¥ 3ï¼šç§»é™¤å°¾éš¨é€—è™Ÿ
            try {
                let cleaned = text.replace(/,\s*([}\]])/g, '$1');
                return JSON.parse(cleaned);
            } catch (e) {}

            // ç­–ç•¥ 4ï¼šå°‡å–®å¼•è™Ÿæ›¿æ›ç‚ºé›™å¼•è™Ÿ
            try {
                let cleaned = text.replace(/'/g, '"');
                return JSON.parse(cleaned);
            } catch (e) {}

            // ç­–ç•¥ 5ï¼šè™•ç†æœªè½‰ç¾©çš„æ›è¡Œç¬¦
            try {
                let cleaned = text.replace(/[\r\n]+/g, ' ').replace(/\s+/g, ' ');
                return JSON.parse(cleaned);
            } catch (e) {}

            // ç­–ç•¥ 6ï¼šç”¨æ­£å‰‡è¡¨é”å¼æå–ç¬¬ä¸€å€‹å®Œæ•´çš„ JSON ç‰©ä»¶
            try {
                const objMatch = text.match(/\{[\s\S]*\}/);
                if (objMatch) {
                    let jsonStr = objMatch[0];
                    // å†æ¬¡å˜—è©¦æ¸…ç†
                    jsonStr = jsonStr.replace(/,\s*([}\]])/g, '$1');
                    return JSON.parse(jsonStr);
                }
            } catch (e) {}

            // ç­–ç•¥ 7ï¼šæå– JSON é™£åˆ—
            try {
                const arrMatch = text.match(/\[[\s\S]*\]/);
                if (arrMatch) {
                    let jsonStr = arrMatch[0];
                    jsonStr = jsonStr.replace(/,\s*([}\]])/g, '$1');
                    return JSON.parse(jsonStr);
                }
            } catch (e) {}

            // æ‰€æœ‰ç­–ç•¥éƒ½å¤±æ•—
            return null;
        }

        class GeminiService {
            constructor() {
                this.baseUrl = "https://generativelanguage.googleapis.com/v1beta/models/";
            }

            async call(prompt, systemInstruction, retryCount = 0) {
                const MAX_RETRIES = 2;

                if (!apiKey) {
                    showError("è«‹å…ˆè¨­å®š API Key");
                    return null;
                }

                const url = `${this.baseUrl}gemini-2.0-flash:generateContent?key=${apiKey}`;
                const payload = {
                    contents: [{ parts: [{ text: prompt }] }],
                    systemInstruction: { parts: [{ text: systemInstruction }] },
                    generationConfig: { responseMimeType: "application/json" }
                };

                try {
                    const res = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!res.ok) {
                        if (res.status === 400) showError("API Key ç„¡æ•ˆ");
                        else if (res.status === 429) showError("è«‹æ±‚éæ–¼é »ç¹");
                        else showError(`API éŒ¯èª¤: ${res.status}`);
                        return null;
                    }

                    const data = await res.json();
                    const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!text) {
                        showError("AI å›æ‡‰ç•°å¸¸");
                        return null;
                    }

                    // ä½¿ç”¨å®¹éŒ¯è§£æ
                    const parsed = tryParseJSON(text);
                    if (parsed) {
                        return parsed;
                    }

                    // è§£æå¤±æ•—ï¼Œå˜—è©¦é‡è©¦
                    if (retryCount < MAX_RETRIES) {
                        console.warn(`JSON è§£æå¤±æ•—ï¼Œæ­£åœ¨é‡è©¦... (${retryCount + 1}/${MAX_RETRIES})`);
                        showFloatingText("AI å›æ‡‰æ ¼å¼ç•°å¸¸ï¼Œæ­£åœ¨é‡è©¦...", canvasWidth/2, canvasHeight/2, '#c07070');
                        return await this.call(prompt, systemInstruction, retryCount + 1);
                    }

                    showError("AI å›æ‡‰æ ¼å¼ç•°å¸¸ï¼Œè«‹é‡è©¦");
                    console.error("JSON è§£æå¤±æ•—ï¼ŒåŸå§‹æ–‡å­—:", text);
                    return null;
                } catch (e) {
                    console.error(e);
                    showError("é€£ç·šå¤±æ•—");
                    return null;
                }
            }

            async generateWorlds() {
                const sys = `ä½ æ˜¯è³‡æ·±å¥‡å¹»ä¸–ç•Œæ¶æ§‹å¸«ã€‚ç”Ÿæˆ3å€‹ç¨ç‰¹çš„TRPGä¸–ç•Œã€‚
æ¯å€‹ä¸–ç•Œéœ€è¦ï¼š
- ç¨ç‰¹çš„ä¸–ç•Œè§€ä¸»é¡Œï¼ˆå¦‚è³½åšé¾å…‹ã€å…‹è˜‡é­¯ã€ä»™ä¿ ã€è’¸æ±½é¾å…‹ã€æœ«æ—¥å»¢åœŸç­‰ï¼‰
- 3å€‹ä¸»è¦é™£ç‡Ÿï¼Œå½¼æ­¤æœ‰è¡çªæˆ–åˆä½œé—œä¿‚
- ä¸–ç•Œçš„æ ¸å¿ƒè¡çªæˆ–è¬åœ˜

å›å‚³ JSONï¼š
{
  "worlds": [{
    "name": "ä¸–ç•Œå(2-4å­—)",
    "theme": "ä¸»é¡Œé¡å‹",
    "desc": "ä¸–ç•ŒèƒŒæ™¯æè¿°(50-80å­—)",
    "conflict": "æ ¸å¿ƒè¡çª(20å­—)",
    "factions": [{
      "name": "é™£ç‡Ÿå",
      "desc": "é™£ç‡Ÿæè¿°(30å­—)",
      "stance": "ç«‹å ´é—œéµè©"
    }]
  }]
}`;
                return await this.call("ç”Ÿæˆ3å€‹ç¨ç‰¹çš„TRPGä¸–ç•Œè¨­å®š", sys);
            }

            async generateOpeningScene(world) {
                const charInfo = getCharacterPromptString();
                const traitMods = getTraitOptionModifiers();
                const traitHint = playerCharacter.traits.length > 0 ?
                    `æ ¹æ“šè§’è‰²æ€§æ ¼ï¼Œé¸é …æ¯”ä¾‹å»ºè­°ï¼šriskæ¬Šé‡${traitMods.risk.toFixed(1)}ã€focusæ¬Šé‡${traitMods.focus.toFixed(1)}ã€normalæ¬Šé‡${traitMods.normal.toFixed(1)}` : '';

                const sys = `ä½ æ˜¯TRPGéŠæˆ²ä¸»æŒäººã€‚ä¸–ç•Œï¼š${world.name} - ${world.desc}
é™£ç‡Ÿï¼š${world.factions.map(f => f.name).join('ã€')}

${charInfo}

ç”ŸæˆéŠæˆ²é–‹å ´ï¼š
1. æè¿°ä¸»è§’ï¼ˆ${playerCharacter.name}ï¼‰é†’ä¾†/æŠµé”çš„å ´æ™¯ï¼Œéœ€ç¬¦åˆå…¶èº«ä¸–èƒŒæ™¯
2. ä»‹ç´¹ç¬¬ä¸€å€‹é‡åˆ°çš„NPCï¼ˆå°‡æˆç‚ºé‡è¦è§’è‰²ï¼‰
3. çµ¦äºˆ3å€‹è¡Œå‹•é¸é …
${traitHint}

NPCéœ€è¦è©³ç´°è¨­å®šï¼ŒåŒ…æ‹¬ï¼šæ€§æ ¼ã€èƒŒæ™¯ã€æ‰€å±¬é™£ç‡Ÿã€èˆ‡å…¶ä»–è§’è‰²çš„æ½›åœ¨é—œä¿‚

å›å‚³ JSONï¼š
{
  "story": "é–‹å ´åŠ‡æƒ…æè¿°(100-150å­—)ï¼Œéœ€æåŠä¸»è§’å§“å",
  "newNPC": {
    "id": "npc_001",
    "name": "NPCåå­—",
    "role": "èº«ä»½/è·æ¥­",
    "desc": "å¤–è²Œèˆ‡æ€§æ ¼æè¿°(50å­—)",
    "faction": 0,
    "personality": "æ€§æ ¼é—œéµè©",
    "secret": "éš±è—çš„ç§˜å¯†æˆ–ç›®çš„"
  },
  "options": [{
    "text": "é¸é …æ–‡å­—",
    "type": "normal/risk/focus",
    "factionIndex": 0,
    "timeAdvance": 1
  }],
  "potentialRelations": [{
    "targetId": "player",
    "type": "neutral",
    "reason": "é—œä¿‚åŸå› "
  }]
}`;
                return await this.call("ç”Ÿæˆé–‹å ´å ´æ™¯", sys);
            }

            async generateNextScene(world, context, action, factions, npcs, calendar) {
                const npcList = npcs.map(n => {
                    const statusInfo = NPC_STATUS_INFO[n.status || 'active'];
                    return `${n.name}(${n.role},ç‹€æ…‹:${statusInfo.name})`;
                }).join('ã€');

                const activeNPCs = npcs.filter(n => n.status === NPC_STATUS.ACTIVE || !n.status);
                const deadNPCs = npcs.filter(n => n.status === NPC_STATUS.DEAD);
                const missingNPCs = npcs.filter(n => n.status === NPC_STATUS.MISSING);

                const charInfo = getCharacterPromptString();
                const traitMods = getTraitOptionModifiers();
                const traitHint = playerCharacter.traits.length > 0 ?
                    `æ ¹æ“šè§’è‰²æ€§æ ¼ï¼Œé¸é …æ¯”ä¾‹å»ºè­°ï¼šriskæ¬Šé‡${traitMods.risk.toFixed(1)}ã€focusæ¬Šé‡${traitMods.focus.toFixed(1)}ã€normalæ¬Šé‡${traitMods.normal.toFixed(1)}` : '';

                const sys = `ä½ æ˜¯TRPGéŠæˆ²ä¸»æŒäººã€‚
ä¸–ç•Œï¼š${world.name}
ç›®å‰æ™‚é–“ï¼š${calendar.getString()} ${calendar.getTimeString()}
${charInfo}
å·²çŸ¥NPCï¼š${npcList || 'ç„¡'}
é™£ç‡Ÿè²æœ›ï¼š${JSON.stringify(factions)}

NPCç‹€æ…‹èªªæ˜ï¼š
- active: æ­£å¸¸æ´»èºï¼Œå¯ä»¥å‡ºç¾åœ¨åŠ‡æƒ…ä¸­
- injured: å—å‚·ï¼Œè¡Œå‹•å—é™
- missing: å¤±è¹¤ï¼Œå¯ä½œç‚ºç·šç´¢æåŠä½†ä¸ç›´æ¥å‡ºç¾
- imprisoned: è¢«å›šç¦ï¼Œéœ€è¦ç‡Ÿæ•‘
- betrayed: å·²èƒŒå›ç©å®¶
- dead: æ­»äº¡ï¼Œçµ•å°ä¸èƒ½å‡ºç¾åœ¨åŠ‡æƒ…ä¸­

${deadNPCs.length > 0 ? `ã€é‡è¦ã€‘å·²æ­»äº¡çš„NPCï¼š${deadNPCs.map(n => n.name).join('ã€')}ï¼Œé€™äº›è§’è‰²çµ•å°ä¸èƒ½å‡ºç¾åœ¨åŠ‡æƒ…ä¸­ï¼` : ''}
${missingNPCs.length > 0 ? `ã€æç¤ºã€‘å¤±è¹¤ä¸­çš„NPCï¼š${missingNPCs.map(n => n.name).join('ã€')}ï¼Œå¯ä»¥ä½œç‚ºèª¿æŸ¥ç·šç´¢æåŠ` : ''}

æ ¹æ“šç©å®¶ï¼ˆ${playerCharacter.name}ï¼‰è¡Œå‹•æ¨é€²åŠ‡æƒ…ã€‚åŠ‡æƒ…ä¸­æ‡‰ä½¿ç”¨ä¸»è§’çš„åå­—ã€‚

è¦å‰‡ï¼š
1. å¯èƒ½é‡åˆ°æ–°NPCï¼ˆæ©Ÿç‡30%ï¼‰ï¼Œæ–°NPCéœ€è¦å®Œæ•´è¨­å®š
2. å¯èƒ½è§¸ç™¼å‘½é‹äº‹ä»¶ï¼ˆæ©Ÿç‡20%ï¼‰ï¼Œçå‹µå‘½é‹é»
3. é¸é …éœ€æ¨™è¨»æ™‚é–“æ¶ˆè€—ï¼ˆ1=ä¸€å€‹æ™‚æ®µï¼Œ2=åŠå¤©ï¼Œ4=ä¸€æ•´å¤©ï¼‰
4. riské¡å‹é¸é …é¢¨éšªæ›´é«˜ä½†å¯èƒ½ç²å¾—æ›´å¤šå‘½é‹é»
5. focusé¡å‹é¸é …å¯æ·±å…¥äº†è§£æŸè§’è‰²ï¼Œå¯èƒ½æ­ç¤ºé—œä¿‚
6. å¦‚æœåŠ‡æƒ…ç™¼å±•å°è‡´NPCç‹€æ…‹æ”¹è®Šï¼ˆå—å‚·ã€å¤±è¹¤ã€æ­»äº¡ç­‰ï¼‰ï¼Œå¿…é ˆåœ¨npcStatusChangesä¸­æ¨™è¨»
${traitHint}

å›å‚³ JSONï¼š
{
  "story": "åŠ‡æƒ…æè¿°(100-150å­—)",
  "newNPC": null æˆ– { "id": "npc_xxx", "name": "", "role": "", "desc": "", "faction": 0, "personality": "", "secret": "" },
  "options": [{ "text": "", "type": "normal/risk/focus", "factionIndex": -1, "timeAdvance": 1 }],
  "fateEvent": null æˆ– { "name": "äº‹ä»¶å", "points": 3, "desc": "äº‹ä»¶æè¿°" },
  "newRelations": [],
  "revealedRelations": [],
  "npcStatusChanges": [{ "id": "npc_xxx", "newStatus": "injured/missing/dead/etc", "reason": "è®Šæ›´åŸå› " }]
}`;
                const prompt = `å‰æƒ…ï¼š${context}\n\nç©å®¶è¡Œå‹•ï¼š${action}`;
                return await this.call(prompt, sys);
            }

            async summarizeHistory(world, log) {
                const sys = `ä½ æ˜¯åŸéŠè©©äººã€‚å°‡å†’éšªç´€éŒ„æ•´ç†æˆè©©æ„çš„ç·¨å¹´å²ã€‚ä½¿ç”¨å„ªç¾çš„æ–‡å­¸èªè¨€ï¼Œä½†ä¿æŒç°¡æ½”ã€‚å›å‚³ JSON: { "content": "Markdownæ ¼å¼çš„æ•…äº‹" }`;
                const logText = log.slice(-20).map(h => `[${h.role}]: ${h.text}`).join("\n");
                return await this.call(`ä¸–ç•Œï¼š${world.name}\nç´€éŒ„:\n${logText}`, sys);
            }

            async generateNextSceneWithDice(world, context, action, factions, npcs, calendar, diceContext) {
                const npcList = npcs.map(n => {
                    const statusInfo = NPC_STATUS_INFO[n.status || 'active'];
                    return `${n.name}(${n.role},ç‹€æ…‹:${statusInfo.name})`;
                }).join('ã€');

                const charInfo = getCharacterPromptString();

                const sys = `ä½ æ˜¯TRPGéŠæˆ²ä¸»æŒäººã€‚
ä¸–ç•Œï¼š${world.name}
ç›®å‰æ™‚é–“ï¼š${calendar.getString()} ${calendar.getTimeString()}
${charInfo}
å·²çŸ¥NPCï¼š${npcList || 'ç„¡'}
é™£ç‡Ÿè²æœ›ï¼š${JSON.stringify(factions)}

${diceContext}

ã€é‡è¦ã€‘è«‹æ ¹æ“šä¸Šè¿°æª¢å®šçµæœä¾†æè¿°å ´æ™¯ï¼š
- å¦‚æœæ˜¯ã€Œæª¢å®šæˆåŠŸã€ï¼Œæè¿°ç©å®¶è¡Œå‹•é †åˆ©çš„å ´æ™¯ï¼Œå¯èƒ½ç²å¾—é¡å¤–æ”¶ç©«
- å¦‚æœæ˜¯ã€Œæª¢å®šå¤±æ•—ã€ï¼Œæè¿°ç©å®¶é­é‡å›°é›£çš„å ´æ™¯ï¼Œå¯èƒ½æœ‰è² é¢å¾Œæœä½†ä¸è¦å¤ªåš´é‡

è¦å‰‡ï¼š
1. å¯èƒ½é‡åˆ°æ–°NPCï¼ˆæ©Ÿç‡30%ï¼‰ï¼Œæ–°NPCéœ€è¦å®Œæ•´è¨­å®š
2. æª¢å®šæˆåŠŸæ™‚æœ‰æ›´é«˜æ©Ÿç‡è§¸ç™¼æ­£é¢å‘½é‹äº‹ä»¶
3. é¸é …éœ€æ¨™è¨»æ™‚é–“æ¶ˆè€—ï¼ˆ1=ä¸€å€‹æ™‚æ®µï¼Œ2=åŠå¤©ï¼Œ4=ä¸€æ•´å¤©ï¼‰
4. å¦‚æœåŠ‡æƒ…ç™¼å±•å°è‡´NPCç‹€æ…‹æ”¹è®Šï¼Œå¿…é ˆåœ¨npcStatusChangesä¸­æ¨™è¨»

å›å‚³ JSONï¼š
{
  "story": "åŠ‡æƒ…æè¿°(100-150å­—)ï¼Œéœ€åæ˜ æª¢å®šçµæœ",
  "newNPC": null æˆ– { "id": "npc_xxx", "name": "", "role": "", "desc": "", "faction": 0, "personality": "", "secret": "" },
  "options": [{ "text": "", "type": "normal/risk/focus", "factionIndex": -1, "timeAdvance": 1 }],
  "fateEvent": null æˆ– { "name": "äº‹ä»¶å", "points": 3, "desc": "äº‹ä»¶æè¿°" },
  "newRelations": [],
  "revealedRelations": [],
  "npcStatusChanges": []
}`;
                const prompt = `å‰æƒ…ï¼š${context}\n\nç©å®¶è¡Œå‹•ï¼š${action}`;
                return await this.call(prompt, sys);
            }

            async compressHistoryLog(log) {
                const sys = `ä½ æ˜¯æ•…äº‹è¨˜éŒ„å“¡ã€‚è«‹å°‡ä»¥ä¸‹äº‹ä»¶è¨˜éŒ„æ¿ƒç¸®ç‚º 100-150 å­—çš„æ‘˜è¦ï¼Œä¿ç•™é—œéµäººç‰©ã€é‡å¤§äº‹ä»¶ã€é‡è¦é¸æ“‡ã€‚åªå›å‚³æ‘˜è¦æ–‡å­—ï¼Œä¸éœ€è¦ JSON æ ¼å¼ã€‚

å›å‚³ JSONï¼š
{
  "summary": "æ‘˜è¦æ–‡å­—ï¼ˆ100-150å­—ï¼‰"
}`;
                const logText = log.map(h => `[${h.role}]: ${h.text}`).join("\n");
                return await this.call(`äº‹ä»¶è¨˜éŒ„:\n${logText}`, sys);
            }
        }

        const aiService = new GeminiService();

        // ============ æ•…äº‹æ‘˜è¦å£“ç¸® ============
        let isCompressing = false;

        async function compressHistory() {
            // ç•¶ historyLog è¶…é 25 ç­†æ™‚è§¸ç™¼å£“ç¸®
            if (historyLog.length <= 25 || isCompressing) return;

            isCompressing = true;
            console.log('é–‹å§‹å£“ç¸®æ­·å²è¨˜éŒ„...');

            try {
                // å–å‡ºå‰ 15 ç­†è¨˜éŒ„é€²è¡Œå£“ç¸®
                const toCompress = historyLog.slice(0, 15);
                const remaining = historyLog.slice(15);

                const result = await aiService.compressHistoryLog(toCompress);

                if (result && result.summary) {
                    // æ›¿æ›ç‚ºæ‘˜è¦
                    historyLog = [
                        { role: 'Summary', text: `ã€å‰æƒ…æ‘˜è¦ã€‘${result.summary}` },
                        ...remaining
                    ];
                    console.log('æ­·å²è¨˜éŒ„å£“ç¸®å®Œæˆï¼Œæ–°é•·åº¦:', historyLog.length);
                }
            } catch (e) {
                console.error('å£“ç¸®æ­·å²è¨˜éŒ„å¤±æ•—:', e);
            }

            isCompressing = false;
        }

        function formatHistoryForPrompt() {
            // æª¢æŸ¥æ˜¯å¦æœ‰æ‘˜è¦
            const hasSummary = historyLog.length > 0 && historyLog[0].role === 'Summary';

            if (hasSummary) {
                const summary = historyLog[0].text;
                const recentEvents = historyLog.slice(1, 11).map(h => `[${h.role}]: ${h.text}`).join("\n");
                return `${summary}\n\nã€è¿‘æœŸäº‹ä»¶ã€‘\n${recentEvents}`;
            } else {
                return historyLog.slice(-10).map(h => `[${h.role}]: ${h.text}`).join("\n");
            }
        }

        // ============ UI å…ƒä»¶ ============
        let buttons = [];
        let particles = [];
        let floatingTexts = [];

        class Particle {
            constructor() { this.reset(); }
            reset() {
                this.x = Math.random() * canvasWidth;
                this.y = Math.random() * canvasHeight;
                this.r = Math.random() * 2 + 0.5;
                this.speed = Math.random() * 0.3 + 0.1;
                this.alpha = Math.random() * 0.4 + 0.1;
                this.drift = (Math.random() - 0.5) * 0.2;
            }
            update() {
                this.y -= this.speed;
                this.x += this.drift;
                if (this.y < -10) {
                    this.y = canvasHeight + 10;
                    this.x = Math.random() * canvasWidth;
                }
            }
            draw() {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class FloatingText {
            constructor(text, x, y, color) {
                this.text = text;
                this.x = x;
                this.y = y;
                this.color = color;
                this.alpha = 1;
                this.vy = -1;
            }
            update() {
                this.y += this.vy;
                this.alpha -= 0.015;
                return this.alpha > 0;
            }
            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.font = '700 20px "Noto Serif TC"';
                ctx.textAlign = 'center';
                ctx.fillText(this.text, this.x, this.y);
                ctx.restore();
            }
        }

        function showFloatingText(text, x, y, color) {
            floatingTexts.push(new FloatingText(text, x, y, color));
        }

        class Button {
            constructor(text, x, y, w, h, callback, type = 'normal') {
                this.text = text;
                this.rect = { x, y, w, h };
                this.callback = callback;
                this.type = type;
                this.hover = false;
                this.hoverAnim = 0;
            }
            update() {
                const { x, y, w, h } = this.rect;
                const inBounds = mouseX >= x && mouseX <= x + w && mouseY >= y && mouseY <= y + h;
                this.hover = inBounds;
                this.hoverAnim += (inBounds ? 0.15 : -0.1);
                this.hoverAnim = Math.max(0, Math.min(1, this.hoverAnim));
            }
            draw() {
                const { x, y, w, h } = this.rect;
                const anim = this.hoverAnim * 3;

                ctx.save();

                // èƒŒæ™¯
                if (this.type === 'world') {
                    ctx.fillStyle = this.hover ? 'rgba(50, 45, 40, 0.95)' : 'rgba(30, 28, 25, 0.9)';
                    ctx.strokeStyle = this.hover ? CONFIG.colors.textGold : '#3a3530';
                } else if (this.type === 'start') {
                    ctx.fillStyle = this.hover ? CONFIG.colors.textGold : 'rgba(40, 35, 30, 0.9)';
                    ctx.strokeStyle = CONFIG.colors.textGold;
                } else if (this.type === 'risk') {
                    ctx.fillStyle = 'rgba(70, 30, 30, 0.9)';
                    ctx.strokeStyle = CONFIG.colors.relationColors.enemy;
                } else if (this.type === 'focus') {
                    ctx.fillStyle = 'rgba(30, 40, 60, 0.9)';
                    ctx.strokeStyle = '#6080b0';
                } else {
                    ctx.fillStyle = this.hover ? 'rgba(50, 48, 45, 0.95)' : 'rgba(35, 33, 30, 0.9)';
                    ctx.strokeStyle = this.hover ? CONFIG.colors.textGold : '#4a4540';
                }

                ctx.lineWidth = 1.5;
                if (this.hover) {
                    ctx.shadowColor = 'rgba(0,0,0,0.4)';
                    ctx.shadowBlur = 10;
                }

                // ç¹ªè£½
                const dx = x - anim/2, dy = y - anim, dw = w + anim, dh = h + anim/2;
                ctx.beginPath();
                this.roundRect(ctx, dx, dy, dw, dh, 6);
                ctx.fill();
                ctx.stroke();
                ctx.shadowBlur = 0;

                // æ–‡å­—
                ctx.font = this.type === 'world' ? fonts.display : 
                           this.type === 'start' ? `700 ${isMobile ? 18 : 22}px "Noto Serif TC"` :
                           `700 ${isMobile ? 16 : 18}px "Noto Serif TC"`;
                ctx.fillStyle = (this.type === 'start' && this.hover) ? '#0d0f14' : 
                                (this.hover ? '#fff' : CONFIG.colors.textPrimary);
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                let disp = this.text;
                if (this.type === 'risk') disp = `âš ï¸ ${this.text}`;
                else if (this.type === 'focus') disp = `ğŸ‘ï¸ ${this.text}`;

                // æ™‚é–“æ¨™è¨˜
                if (this.timeAdvance) {
                    const timeStr = this.timeAdvance === 1 ? 'â±' : 
                                   this.timeAdvance === 2 ? 'â±â±' : 'â±â±â±';
                    disp = `${disp} ${timeStr}`;
                }

                this.wrapText(ctx, disp, x + w/2, y + h/2 - anim, w - 20);
                ctx.restore();
            }
            roundRect(ctx, x, y, w, h, r) {
                ctx.moveTo(x+r, y);
                ctx.lineTo(x+w-r, y);
                ctx.quadraticCurveTo(x+w, y, x+w, y+r);
                ctx.lineTo(x+w, y+h-r);
                ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
                ctx.lineTo(x+r, y+h);
                ctx.quadraticCurveTo(x, y+h, x, y+h-r);
                ctx.lineTo(x, y+r);
                ctx.quadraticCurveTo(x, y, x+r, y);
                ctx.closePath();
            }
            wrapText(ctx, text, x, centerY, maxW) {
                const lines = [];
                let line = '';
                for (const char of text) {
                    if (ctx.measureText(line + char).width > maxW && line) {
                        lines.push(line);
                        line = char;
                    } else line += char;
                }
                lines.push(line);
                const lh = isMobile ? 22 : 26;
                const startY = centerY - ((lines.length - 1) * lh) / 2;
                lines.forEach((l, i) => ctx.fillText(l, x, startY + i * lh));
            }
        }

        class Typewriter {
            constructor() { this.text = ""; this.idx = 0; this.done = true; }
            start(text) {
                this.text = text;
                this.idx = 0;
                this.done = false;
            }
            skip() { this.idx = this.text.length; this.done = true; }
            update() {
                if (this.done) return;
                this.idx += isMobile ? 0.7 : 0.5;
                if (this.idx >= this.text.length) {
                    this.idx = this.text.length;
                    this.done = true;
                    onTypingComplete();
                }
            }
            draw() {
                if (currentState === STATE.LOADING || currentState === STATE.INIT || 
                    currentState === STATE.WORLD_SELECT || currentState === STATE.WORLD_INTRO) return;

                const maxW = Math.min(canvasWidth - 40, 700);
                const startX = (canvasWidth - maxW) / 2;
                const startY = isMobile ? 95 : 120;
                const lh = isMobile ? 30 : 36;

                ctx.save();
                ctx.font = fonts.body;
                ctx.fillStyle = CONFIG.colors.textPrimary;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 2;

                const str = this.text.substring(0, Math.floor(this.idx));
                let line = '', cy = startY;
                for (const char of str) {
                    if (ctx.measureText(line + char).width > maxW && line) {
                        ctx.fillText(line, startX, cy);
                        line = char;
                        cy += lh;
                    } else line += char;
                }
                ctx.fillText(line, startX, cy);
                ctx.restore();
            }
        }

        const typewriter = new Typewriter();

        // ============ é™£ç‡Ÿ HUD ============
        function drawFactionHUD() {
            if (!currentWorld || currentState < STATE.TYPING) return;

            const pad = 10;
            let boxW, boxH, startX, startY;

            if (isMobile) {
                return; // æ‰‹æ©Ÿç‰ˆæš«æ™‚éš±è—
            } else {
                boxW = 180;
                boxH = 110;
                startX = canvasWidth - boxW - 20;
                startY = 70;
            }

            ctx.save();
            ctx.fillStyle = CONFIG.colors.panelBg;
            ctx.strokeStyle = CONFIG.colors.panelBorder;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.roundRect(startX, startY, boxW, boxH, 6);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = CONFIG.colors.textDim;
            ctx.font = fonts.small;
            ctx.textAlign = 'center';
            ctx.fillText("é™£ç‡Ÿè²æœ›", startX + boxW/2, startY + 18);

            let cy = startY + 38;
            factionData.forEach((f, i) => {
                ctx.font = fonts.small;
                ctx.textAlign = 'left';
                ctx.fillStyle = CONFIG.colors.textPrimary;
                ctx.fillText(f.name, startX + pad, cy);

                ctx.textAlign = 'right';
                ctx.fillStyle = CONFIG.colors.factions[i];
                ctx.fillText(f.rep, startX + boxW - pad, cy);

                cy += 6;
                const barW = boxW - pad*2;
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fillRect(startX + pad, cy, barW, 3);
                ctx.fillStyle = CONFIG.colors.factions[i];
                ctx.fillRect(startX + pad, cy, (f.rep/100)*barW, 3);
                cy += 18;
            });

            ctx.restore();
        }

        // ============ æ¨¡æ…‹æ§åˆ¶ ============
        function toggleRelationModal(show) {
            document.getElementById('relation-modal').classList.toggle('show', show);
            if (show) {
                initRelationCanvas();
                drawRelationNetwork();
            }
        }

        function toggleLogModal(show) {
            document.getElementById('log-modal').classList.toggle('show', show);
        }

        function toggleSettingsModal(show) {
            document.getElementById('settings-modal').classList.toggle('show', show);
            if (show) document.getElementById('api-key-input').value = apiKey;
        }

        function toggleWorldIntroModal(show) {
            document.getElementById('world-intro-modal').classList.toggle('show', show);
        }

        function showError(msg) {
            const toast = document.getElementById('error-toast');
            toast.textContent = msg;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 4000);
        }

        function saveApiKey() {
            const key = document.getElementById('api-key-input').value.trim();
            if (!key) { showError("è«‹è¼¸å…¥ API Key"); return; }
            apiKey = key;
            localStorage.setItem('gemini_api_key', key);
            toggleSettingsModal(false);
            if (currentState === STATE.INIT) startWorldGeneration();
        }

        // ============ äº‹ä»¶è™•ç† ============
        document.getElementById('btn-relation').addEventListener('click', () => toggleRelationModal(true));
        document.getElementById('btn-timeline').addEventListener('click', () => toggleTimelineModal(true));
        document.getElementById('btn-sound').addEventListener('click', () => {
            isSoundOn = !isSoundOn;
            document.getElementById('btn-sound').textContent = isSoundOn ? 'ğŸ”Š' : 'ğŸ”‡';
            document.getElementById('btn-sound').classList.toggle('active', isSoundOn);
        });
        document.getElementById('btn-log').addEventListener('click', async () => {
            if (!currentWorld) { showError("è«‹å…ˆé–‹å§‹éŠæˆ²"); return; }
            toggleLogModal(true);
            document.getElementById('log-body').innerHTML = 'ğŸ–‹ï¸ æ­£åœ¨æ’°å¯«ç·¨å¹´å²...';
            const res = await aiService.summarizeHistory(currentWorld, historyLog);
            document.getElementById('log-body').innerHTML = res?.content?.replace(/\n/g, '<br>') || 'ç´€éŒ„ä¸è¶³...';
        });
        document.getElementById('btn-settings').addEventListener('click', () => toggleSettingsModal(true));

        document.addEventListener('keydown', e => {
            if (e.key === 'Escape') {
                toggleRelationModal(false);
                toggleTimelineModal(false);
                toggleLogModal(false);
                toggleSettingsModal(false);
                toggleWorldIntroModal(false);
                toggleCharacterCreateModal(false);
            }
        });

        // Canvas äº‹ä»¶
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('click', handleClick);

        let touchStart = 0;
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            touchStart = Date.now();
            const t = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            mouseX = t.clientX - rect.left;
            mouseY = t.clientY - rect.top;
        }, { passive: false });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            const t = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            mouseX = t.clientX - rect.left;
            mouseY = t.clientY - rect.top;
        }, { passive: false });

        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            if (Date.now() - touchStart < 300) handleClick();
        }, { passive: false });

        function handleClick() {
            if (currentState === STATE.TYPING) {
                typewriter.skip();
            } else {
                for (const b of buttons) {
                    if (b.hover) { b.callback(); break; }
                }
            }
        }

        // ============ éŠæˆ²æµç¨‹ ============
        function init() {
            resize();
            window.addEventListener('resize', resize);
            for (let i = 0; i < 50; i++) particles.push(new Particle());
            currentState = STATE.INIT;
            createStartButton();

            // è¼‰å…¥å­˜æª”é»
            loadSavePointsFromStorage();

            // æª¢æŸ¥æ˜¯å¦æœ‰è‡ªå‹•å­˜æª”
            checkAutoSave();

            loop();
        }

        function resize() {
            const dpr = window.devicePixelRatio || 1;
            canvasWidth = window.innerWidth;
            canvasHeight = window.innerHeight;
            isMobile = canvasWidth < 600;
            canvas.width = canvasWidth * dpr;
            canvas.height = canvasHeight * dpr;
            canvas.style.width = canvasWidth + 'px';
            canvas.style.height = canvasHeight + 'px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            fonts = CONFIG.getFonts(isMobile);
            particles.forEach(p => { p.x = Math.random() * canvasWidth; p.y = Math.random() * canvasHeight; });
            recalcLayout();
        }

        function recalcLayout() {
            if (currentState === STATE.INIT) createStartButton();
            else if (currentState === STATE.WORLD_SELECT) setupWorldSelectUI();
            else if (currentState === STATE.CHOICE) generateOptionsUI();
        }

        function createStartButton() {
            const btnW = isMobile ? canvasWidth * 0.7 : 280;
            const btnH = 55;
            buttons = [new Button("å•Ÿå‹•å‰µä¸–å¼•æ“", canvasWidth/2 - btnW/2, canvasHeight/2 - btnH/2, btnW, btnH, () => {
                if (!apiKey) toggleSettingsModal(true);
                else startWorldGeneration();
            }, 'start')];
        }

        async function startWorldGeneration() {
            currentState = STATE.LOADING;
            loadingText = "âœ§ ç·¨ç¹”ä¸–ç•Œç·š...";
            const data = await aiService.generateWorlds();
            if (data?.worlds?.length) {
                generatedWorlds = data.worlds;
                setupWorldSelectUI();
            } else {
                currentState = STATE.INIT;
                createStartButton();
            }
        }

        function setupWorldSelectUI() {
            currentState = STATE.WORLD_SELECT;
            buttons = [];
            const gap = isMobile ? 12 : 20;
            const cardW = isMobile ? canvasWidth * 0.85 : 260;
            const cardH = isMobile ? 70 : 100;
            const totalH = generatedWorlds.length * cardH + (generatedWorlds.length - 1) * gap;
            const startY = (canvasHeight - totalH) / 2;
            const startX = (canvasWidth - cardW) / 2;

            generatedWorlds.forEach((w, i) => {
                buttons.push(new Button(w.name, startX, startY + i * (cardH + gap), cardW, cardH, () => showWorldIntro(w), 'world'));
            });
        }

        function showWorldIntro(world) {
            currentWorld = world;

            let factionsHTML = world.factions.map((f, i) => `
                <div class="faction-card" style="border-left: 3px solid ${CONFIG.colors.factions[i]};">
                    <h4>${f.name}</h4>
                    <p>${f.desc}</p>
                </div>
            `).join('');

            document.getElementById('world-intro-content').innerHTML = `
                <h2>${world.name}</h2>
                <div class="desc">${world.desc}</div>
                ${world.conflict ? `<div style="color:#deb887;font-size:16px;margin-bottom:20px;">ã€Œ${world.conflict}ã€</div>` : ''}
                <div class="factions">${factionsHTML}</div>
                <button class="start-adventure-btn" onclick="openCharacterCreation()">è¸å…¥å‘½é‹</button>
            `;

            toggleWorldIntroModal(true);
        }

        function openCharacterCreation() {
            toggleWorldIntroModal(false);
            toggleCharacterCreateModal(true);
        }

        async function startAdventureWithCharacter() {
            // é‡ç½®ç³»çµ±
            CALENDAR.reset();
            fatePoints = 0;
            npcs = [];
            relationships = [];
            historyLog = [];
            playerCharacter.x = 0;
            playerCharacter.y = 0;

            // åˆå§‹åŒ–é™£ç‡Ÿ
            factionData = currentWorld.factions.map(f => ({ name: f.name, rep: 50 }));

            // æ‡‰ç”¨è§’è‰²èƒŒæ™¯çš„é™£ç‡ŸåŠ æˆ
            const bgInfo = BACKGROUND_INFO[playerCharacter.background];
            if (bgInfo && bgInfo.factionBonus >= 0 && bgInfo.factionBonus < factionData.length) {
                factionData[bgInfo.factionBonus].rep += 15;
                showFloatingText(`${factionData[bgInfo.factionBonus].name} è²æœ› +15`, canvasWidth/2, 150, CONFIG.colors.factions[bgInfo.factionBonus]);
            }

            // é¡¯ç¤º UI
            document.getElementById('calendar-display').style.display = 'block';
            document.getElementById('fate-display').style.display = 'flex';
            document.getElementById('fate-value').textContent = '0';
            CALENDAR.updateDisplay();
            updateNPCBadge();

            // ç”Ÿæˆé–‹å ´
            currentState = STATE.LOADING;
            loadingText = "âœ§ å‘½é‹ä¹‹è¼ªè½‰å‹•...";
            storyContext = `${currentWorld.name}ï¼š${currentWorld.desc}`;

            const res = await aiService.generateOpeningScene(currentWorld);
            if (res) {
                processSceneResult(res, "å†’éšªé–‹å§‹");
            } else {
                showError("å ´æ™¯ç”Ÿæˆå¤±æ•—");
                currentState = STATE.INIT;
                createStartButton();
            }
        }

        // ä¿ç•™ beginAdventure ä½œç‚ºå‘å¾Œå…¼å®¹ï¼ˆç”¨æ–¼è®€å–å­˜æª”å¾Œç¹¼çºŒï¼‰
        async function beginAdventure() {
            await startAdventureWithCharacter();
        }

        async function triggerSceneGeneration(action, timeAdvance = 1) {
            currentState = STATE.LOADING;
            loadingText = "âœ§ å‘½é‹æ¨æ¼”ä¸­...";

            // æª¢æŸ¥ä¸¦å£“ç¸®æ­·å²è¨˜éŒ„
            await compressHistory();

            // æ™‚é–“æµé€
            CALENDAR.advance(timeAdvance);

            historyLog.push({ role: 'Player', text: action });

            const res = await aiService.generateNextScene(
                currentWorld,
                storyContext,
                action,
                factionData,
                npcs,
                CALENDAR
            );

            if (res) {
                processSceneResult(res, action);
            } else {
                loadingText = "é€£ç·šä¸­æ–·...";
                buttons = [new Button("é‡è©¦", canvasWidth/2 - 60, canvasHeight/2 + 50, 120, 50, () => triggerSceneGeneration(action, timeAdvance))];
            }
        }

        function processSceneResult(res, action) {
            storyContext = res.story;
            currentOptions = res.options || [];
            historyLog.push({ role: 'GM', text: res.story });

            // æ–° NPC
            if (res.newNPC) {
                addNPC(res.newNPC);
                // æ·»åŠ èˆ‡ç©å®¶çš„åˆå§‹é—œä¿‚
                if (res.potentialRelations) {
                    for (const rel of res.potentialRelations) {
                        if (rel.targetId === 'player') {
                            addRelationship(res.newNPC.id, 'player', rel.type, true);
                        }
                    }
                } else {
                    addRelationship(res.newNPC.id, 'player', 'neutral', true);
                }
                // å»ºç«‹å­˜æª”é»
                checkAndCreateSavePoint('newNPC', res.newNPC.name);
            }

            // æ–°é—œä¿‚
            if (res.newRelations) {
                for (const rel of res.newRelations) {
                    addRelationship(rel.from, rel.to, rel.type, rel.revealed || false);
                }
            }

            // æ­ç¤ºé—œä¿‚
            if (res.revealedRelations) {
                for (const rel of res.revealedRelations) {
                    revealRelationship(rel.from, rel.to);
                }
            }

            // NPC ç‹€æ…‹è®Šæ›´
            if (res.npcStatusChanges && res.npcStatusChanges.length > 0) {
                for (const change of res.npcStatusChanges) {
                    if (change.id && change.newStatus) {
                        updateNPCStatus(change.id, change.newStatus, change.reason);
                    }
                }
            }

            // å‘½é‹äº‹ä»¶
            if (res.fateEvent) {
                setTimeout(() => {
                    addFatePoints(res.fateEvent.points);
                    historyLog.push({ role: 'Fate', text: `ã€${res.fateEvent.name}ã€‘${res.fateEvent.desc} (+${res.fateEvent.points}å‘½é‹é»)` });
                }, 1500);
                // å»ºç«‹é‡å¤§å­˜æª”é»
                checkAndCreateSavePoint('fate', res.fateEvent.name);
            }

            // æª¢æŸ¥æœˆæœ«å­˜æª”é»
            checkAndCreateSavePoint('monthly');

            currentState = STATE.TYPING;
            typewriter.start(res.story);

            // è‡ªå‹•å­˜æª”
            autoSave();
        }

        function onTypingComplete() {
            currentState = STATE.CHOICE;
            generateOptionsUI();
        }

        function generateOptionsUI() {
            buttons = [];
            const btnW = Math.min(isMobile ? canvasWidth * 0.9 : 480, canvasWidth - 30);
            const btnH = isMobile ? 55 : 58;
            const gap = isMobile ? 10 : 14;
            const totalH = currentOptions.length * btnH + (currentOptions.length - 1) * gap;
            const startY = canvasHeight - totalH - (isMobile ? 90 : 70);
            const centerX = (canvasWidth - btnW) / 2;

            currentOptions.forEach((opt, i) => {
                const btn = new Button(
                    opt.text,
                    centerX,
                    startY + i * (btnH + gap),
                    btnW,
                    btnH,
                    () => handleOption(opt),
                    opt.type || 'normal'
                );
                btn.timeAdvance = opt.timeAdvance || 1;
                buttons.push(btn);
            });
        }

        function handleOption(opt) {
            // é™£ç‡Ÿè²æœ›
            if (opt.factionIndex >= 0 && opt.factionIndex < factionData.length) {
                const change = opt.type === 'risk' ? 8 : 4;
                factionData[opt.factionIndex].rep = Math.min(100, factionData[opt.factionIndex].rep + change);
            }

            // å° risk é¡å‹é¸é …å»ºç«‹å­˜æª”é»ä¸¦è§¸ç™¼æ“²éª°
            if (opt.type === 'risk') {
                checkAndCreateSavePoint('risk');

                // é¸æ“‡æœ€ç›¸é—œçš„å±¬æ€§é€²è¡Œæª¢å®š
                const relevantStat = opt.checkStat || determineRelevantStat(opt.text);

                performDiceCheck(
                    'å†’éšªæŠ‰æ“‡',
                    relevantStat,
                    'hard',
                    (result) => {
                        // æ ¹æ“šæª¢å®šçµæœèª¿æ•´è¡Œå‹•æ–‡å­—
                        const actionText = result.success ?
                            `${opt.text}ï¼ˆæª¢å®šæˆåŠŸï¼Œè¡Œå‹•é †åˆ©ï¼‰` :
                            `${opt.text}ï¼ˆæª¢å®šå¤±æ•—ï¼Œé­é‡å›°é›£ï¼‰`;

                        historyLog.push({
                            role: 'Dice',
                            text: `ã€${STAT_NAMES[relevantStat]}æª¢å®šã€‘æ“²éª° ${result.result}ï¼Œç›®æ¨™ ${result.threshold}ï¼Œ${result.success ? 'æˆåŠŸ' : 'å¤±æ•—'}${result.rerolled ? 'ï¼ˆå‘½é‹ä»‹å…¥ï¼‰' : ''}`
                        });

                        autoSave();
                        triggerSceneGenerationWithDiceResult(actionText, opt.timeAdvance || 1, result);
                    }
                );
            } else {
                // é¸æ“‡å‰å…ˆå­˜æª”ï¼Œç¢ºä¿ç©å®¶çš„é¸æ“‡è¢«è¨˜éŒ„
                autoSave();
                triggerSceneGeneration(opt.text, opt.timeAdvance || 1);
            }
        }

        function determineRelevantStat(optionText) {
            // æ ¹æ“šé¸é …æ–‡å­—åˆ¤æ–·æœ€ç›¸é—œçš„å±¬æ€§
            const strengthKeywords = ['æˆ°é¬¥', 'æ”»æ“Š', 'é˜²ç¦¦', 'åŠ›é‡', 'æ‰“', 'æ®º', 'æé¬¥', 'è¡', 'ç ´å£', 'èˆ‰'];
            const wisdomKeywords = ['èª¿æŸ¥', 'ç ”ç©¶', 'åˆ†æ', 'è§€å¯Ÿ', 'è§£è¬', 'é–±è®€', 'æ€è€ƒ', 'è¨ˆç®—', 'è¨˜æ†¶', 'å­¸ç¿’'];
            const charismaKeywords = ['èªªæœ', 'äº¤æ¶‰', 'è«‡åˆ¤', 'å¨åš‡', 'æ¬ºé¨™', 'é­…æƒ‘', 'ç¤¾äº¤', 'äº¤è«‡', 'è«‹æ±‚', 'è©¢å•'];
            const luckKeywords = ['è³­', 'ç¢°é‹æ°£', 'å˜—è©¦', 'å†’éšª', 'éš¨æ©Ÿ', 'æŠ½', 'çŒœ'];

            const text = optionText.toLowerCase();

            if (strengthKeywords.some(k => text.includes(k))) return 'strength';
            if (wisdomKeywords.some(k => text.includes(k))) return 'wisdom';
            if (charismaKeywords.some(k => text.includes(k))) return 'charisma';
            if (luckKeywords.some(k => text.includes(k))) return 'luck';

            // é»˜èªä½¿ç”¨ç©å®¶æœ€é«˜çš„å±¬æ€§
            const stats = playerCharacter.stats;
            let maxStat = 'strength';
            let maxValue = 0;
            for (const [stat, value] of Object.entries(stats)) {
                if (value > maxValue) {
                    maxValue = value;
                    maxStat = stat;
                }
            }
            return maxStat;
        }

        async function triggerSceneGenerationWithDiceResult(action, timeAdvance, diceResult) {
            currentState = STATE.LOADING;
            loadingText = "âœ§ å‘½é‹æ¨æ¼”ä¸­...";

            // æª¢æŸ¥ä¸¦å£“ç¸®æ­·å²è¨˜éŒ„
            await compressHistory();

            // æ™‚é–“æµé€
            CALENDAR.advance(timeAdvance);

            historyLog.push({ role: 'Player', text: action });

            // å°‡éª°å­çµæœå‚³çµ¦ AI
            const diceContext = diceResult.success ?
                `ã€æª¢å®šæˆåŠŸã€‘ç©å®¶çš„${STAT_NAMES[diceResult.stat]}æª¢å®šæˆåŠŸï¼ˆæ“²å‡º${diceResult.result}ï¼Œç›®æ¨™${diceResult.threshold}ï¼‰ï¼Œè¡Œå‹•é †åˆ©é€²è¡Œã€‚` :
                `ã€æª¢å®šå¤±æ•—ã€‘ç©å®¶çš„${STAT_NAMES[diceResult.stat]}æª¢å®šå¤±æ•—ï¼ˆæ“²å‡º${diceResult.result}ï¼Œç›®æ¨™${diceResult.threshold}ï¼‰ï¼Œè¡Œå‹•é‡åˆ°å›°é›£æˆ–ç”¢ç”Ÿæ„å¤–å¾Œæœã€‚`;

            const res = await aiService.generateNextSceneWithDice(
                currentWorld,
                storyContext,
                action,
                factionData,
                npcs,
                CALENDAR,
                diceContext
            );

            if (res) {
                processSceneResult(res, action);
            } else {
                loadingText = "é€£ç·šä¸­æ–·...";
                buttons = [new Button("é‡è©¦", canvasWidth/2 - 60, canvasHeight/2 + 50, 120, 50, () => triggerSceneGenerationWithDiceResult(action, timeAdvance, diceResult))];
            }
        }

        // ============ ä¸»è¿´åœˆ ============
        function loop() {
            requestAnimationFrame(loop);

            // èƒŒæ™¯
            ctx.fillStyle = CONFIG.colors.bg;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // ç²’å­
            particles.forEach(p => { p.update(); p.draw(); });

            // æšˆå½±
            const grad = ctx.createRadialGradient(canvasWidth/2, canvasHeight/2, canvasHeight*0.2, canvasWidth/2, canvasHeight/2, canvasHeight*0.9);
            grad.addColorStop(0, 'rgba(0,0,0,0)');
            grad.addColorStop(1, 'rgba(0,0,0,0.4)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // è¼‰å…¥ä¸­
            if (currentState === STATE.LOADING) {
                ctx.fillStyle = '#66a3e0';
                ctx.font = fonts.displayLarge;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const pulse = 1 + Math.sin(Date.now() / 300) * 0.02;
                ctx.save();
                ctx.translate(canvasWidth/2, canvasHeight/2);
                ctx.scale(pulse, pulse);
                ctx.fillText(loadingText, 0, 0);
                ctx.restore();
            }

            // éŠæˆ²é¢æ¿
            if (currentState >= STATE.TYPING) {
                const panelH = isMobile ? canvasHeight * 0.42 : canvasHeight * 0.38;
                const panelY = canvasHeight - panelH;
                ctx.fillStyle = CONFIG.colors.panelBg;
                ctx.fillRect(0, panelY, canvasWidth, panelH);
                ctx.beginPath();
                ctx.moveTo(0, panelY);
                ctx.lineTo(canvasWidth, panelY);
                ctx.strokeStyle = CONFIG.colors.panelBorder;
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // HUD
            drawFactionHUD();

            // æ‰“å­—æ©Ÿ
            typewriter.update();
            typewriter.draw();

            // æŒ‰éˆ•
            buttons.forEach(b => { b.update(); b.draw(); });

            // æµ®å‹•æ–‡å­—
            floatingTexts = floatingTexts.filter(ft => {
                const alive = ft.update();
                if (alive) ft.draw();
                return alive;
            });
        }

        // å•Ÿå‹•
        init();
    </script>
</body>
</html>
